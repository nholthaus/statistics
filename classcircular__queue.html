<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Queue: circular_queue&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Queue
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A C++17 Library of various `queue` containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcircular__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcircular__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">circular_queue&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fixed capacity, STL-style, templated circular buffer.  
 <a href="classcircular__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="circular__queue_8h_source.html">circular_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant iterator for the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> class.  <a href="classcircular__queue_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcircular__queue_1_1const__queue__pointer.html">const_queue_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant pointer with parity  <a href="structcircular__queue_1_1const__queue__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator for the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> class.  <a href="classcircular__queue_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer with parity  <a href="structcircular__queue_1_1queue__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5731136205f641f6d4c9e10343c23a5a"><td class="memItemLeft" align="right" valign="top"><a id="a5731136205f641f6d4c9e10343c23a5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> = Alloc</td></tr>
<tr class="memdesc:a5731136205f641f6d4c9e10343c23a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of object used to dynamically allocate memory. <br /></td></tr>
<tr class="separator:a5731136205f641f6d4c9e10343c23a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab769df42cea6cf894a44007b33610ead"><td class="memItemLeft" align="right" valign="top"><a id="ab769df42cea6cf894a44007b33610ead"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a> = ptrdiff_t</td></tr>
<tr class="memdesc:ab769df42cea6cf894a44007b33610ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type, identical to:iterator_traits&lt;iterator&gt;::difference_type. <br /></td></tr>
<tr class="separator:ab769df42cea6cf894a44007b33610ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7304fc81b0bc9d7ec76da67a4f718de4"><td class="memItemLeft" align="right" valign="top"><a id="a7304fc81b0bc9d7ec76da67a4f718de4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> = size_t</td></tr>
<tr class="memdesc:a7304fc81b0bc9d7ec76da67a4f718de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral type that can represent any non-negative value of difference_type. <br /></td></tr>
<tr class="separator:a7304fc81b0bc9d7ec76da67a4f718de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe7f924c5a762af802d72fc83aa880e"><td class="memItemLeft" align="right" valign="top"><a id="afbe7f924c5a762af802d72fc83aa880e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> = T</td></tr>
<tr class="memdesc:afbe7f924c5a762af802d72fc83aa880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template parameter (T), representing the values stored in the container. <br /></td></tr>
<tr class="separator:afbe7f924c5a762af802d72fc83aa880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936ce8fe8200386264d1b81b805054d"><td class="memItemLeft" align="right" valign="top"><a id="a4936ce8fe8200386264d1b81b805054d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a4936ce8fe8200386264d1b81b805054d">pointer</a> = T *</td></tr>
<tr class="memdesc:a4936ce8fe8200386264d1b81b805054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the default allocator: value_type*. <br /></td></tr>
<tr class="separator:a4936ce8fe8200386264d1b81b805054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e6aa86b647b9e4a6ec34b29074d4b7"><td class="memItemLeft" align="right" valign="top"><a id="a00e6aa86b647b9e4a6ec34b29074d4b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a00e6aa86b647b9e4a6ec34b29074d4b7">const_pointer</a> = const T *</td></tr>
<tr class="memdesc:a00e6aa86b647b9e4a6ec34b29074d4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for pointer to constant T object. <br /></td></tr>
<tr class="separator:a00e6aa86b647b9e4a6ec34b29074d4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdddd098481b69659d443474118ba0c"><td class="memItemLeft" align="right" valign="top"><a id="a6cdddd098481b69659d443474118ba0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a6cdddd098481b69659d443474118ba0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for data references. <br /></td></tr>
<tr class="separator:a6cdddd098481b69659d443474118ba0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86954fc28d72c114c8e9d443c56b2a29"><td class="memItemLeft" align="right" valign="top"><a id="a86954fc28d72c114c8e9d443c56b2a29"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a86954fc28d72c114c8e9d443c56b2a29">const_reference</a> = const T &amp;</td></tr>
<tr class="memdesc:a86954fc28d72c114c8e9d443c56b2a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reference to constant T object. <br /></td></tr>
<tr class="separator:a86954fc28d72c114c8e9d443c56b2a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e91bd80e03de71446f52f85d22124"><td class="memItemLeft" align="right" valign="top"><a id="af27e91bd80e03de71446f52f85d22124"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af27e91bd80e03de71446f52f85d22124">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> &gt;</td></tr>
<tr class="memdesc:af27e91bd80e03de71446f52f85d22124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterators. <br /></td></tr>
<tr class="separator:af27e91bd80e03de71446f52f85d22124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318024c96f5b8a07404df79f29804288"><td class="memItemLeft" align="right" valign="top"><a id="a318024c96f5b8a07404df79f29804288"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a318024c96f5b8a07404df79f29804288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for constant reverse iterators. <br /></td></tr>
<tr class="separator:a318024c96f5b8a07404df79f29804288"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to construct, destruct, and assign the container. </p>
</div></td></tr>
<tr class="memitem:a91892bdf329fea736011f0028444c90d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a91892bdf329fea736011f0028444c90d">circular_queue</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> <a class="el" href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1">capacity</a>, const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;alloc=<a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>())</td></tr>
<tr class="memdesc:a91892bdf329fea736011f0028444c90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classcircular__queue.html#a91892bdf329fea736011f0028444c90d">More...</a><br /></td></tr>
<tr class="separator:a91892bdf329fea736011f0028444c90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2e8bd3f0896605cf28c4c5e2898e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a4ef2e8bd3f0896605cf28c4c5e2898e8">circular_queue</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> <a class="el" href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1">capacity</a>, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val, const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;alloc=<a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>())</td></tr>
<tr class="memdesc:a4ef2e8bd3f0896605cf28c4c5e2898e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill constructor  <a href="classcircular__queue.html#a4ef2e8bd3f0896605cf28c4c5e2898e8">More...</a><br /></td></tr>
<tr class="separator:a4ef2e8bd3f0896605cf28c4c5e2898e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501f5b60f6febaf29159de29b1ab67d1"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a501f5b60f6febaf29159de29b1ab67d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a501f5b60f6febaf29159de29b1ab67d1">circular_queue</a> (InputIterator first, InputIterator last, const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;alloc=<a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>(), typename std::enable_if&lt;!std::is_integral&lt; InputIterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a501f5b60f6febaf29159de29b1ab67d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range Constructor.  <a href="classcircular__queue.html#a501f5b60f6febaf29159de29b1ab67d1">More...</a><br /></td></tr>
<tr class="separator:a501f5b60f6febaf29159de29b1ab67d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2750feffc24a9db7a3f3a0aaf3407489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a2750feffc24a9db7a3f3a0aaf3407489">circular_queue</a> (std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il, const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;alloc=<a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>())</td></tr>
<tr class="memdesc:a2750feffc24a9db7a3f3a0aaf3407489"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from initializer list  <a href="classcircular__queue.html#a2750feffc24a9db7a3f3a0aaf3407489">More...</a><br /></td></tr>
<tr class="separator:a2750feffc24a9db7a3f3a0aaf3407489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460f85ea9d2ea568a3ff1d8f622dece"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ac460f85ea9d2ea568a3ff1d8f622dece">circular_queue</a> (const <a class="el" href="classcircular__queue.html">circular_queue</a> &amp;other)</td></tr>
<tr class="memdesc:ac460f85ea9d2ea568a3ff1d8f622dece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="classcircular__queue.html#ac460f85ea9d2ea568a3ff1d8f622dece">More...</a><br /></td></tr>
<tr class="separator:ac460f85ea9d2ea568a3ff1d8f622dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfb5d2b8f82f907c48b540fd9571e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aeccfb5d2b8f82f907c48b540fd9571e5">circular_queue</a> (<a class="el" href="classcircular__queue.html">circular_queue</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aeccfb5d2b8f82f907c48b540fd9571e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="classcircular__queue.html#aeccfb5d2b8f82f907c48b540fd9571e5">More...</a><br /></td></tr>
<tr class="separator:aeccfb5d2b8f82f907c48b540fd9571e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a03bc81f048cd24f3879de76004399bae"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a03bc81f048cd24f3879de76004399bae">~circular_queue</a> ()</td></tr>
<tr class="memdesc:a03bc81f048cd24f3879de76004399bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classcircular__queue.html#a03bc81f048cd24f3879de76004399bae">More...</a><br /></td></tr>
<tr class="separator:a03bc81f048cd24f3879de76004399bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a74e5626258e7a0e5e7530bd231857240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html">circular_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a74e5626258e7a0e5e7530bd231857240">operator=</a> (const <a class="el" href="classcircular__queue.html">circular_queue</a> &amp;other)</td></tr>
<tr class="memdesc:a74e5626258e7a0e5e7530bd231857240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content.  <a href="classcircular__queue.html#a74e5626258e7a0e5e7530bd231857240">More...</a><br /></td></tr>
<tr class="separator:a74e5626258e7a0e5e7530bd231857240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d679a6e39e5272ae77eb57df0fb764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html">circular_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a66d679a6e39e5272ae77eb57df0fb764">operator=</a> (<a class="el" href="classcircular__queue.html">circular_queue</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a66d679a6e39e5272ae77eb57df0fb764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content.  <a href="classcircular__queue.html#a66d679a6e39e5272ae77eb57df0fb764">More...</a><br /></td></tr>
<tr class="separator:a66d679a6e39e5272ae77eb57df0fb764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac0bf2149c5f211dcf11e00c0b63bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html">circular_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a1ac0bf2149c5f211dcf11e00c0b63bfa">operator=</a> (std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a1ac0bf2149c5f211dcf11e00c0b63bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content.  <a href="classcircular__queue.html#a1ac0bf2149c5f211dcf11e00c0b63bfa">More...</a><br /></td></tr>
<tr class="separator:a1ac0bf2149c5f211dcf11e00c0b63bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bcf110b0944ec21ff21b763cfc374d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af7bcf110b0944ec21ff21b763cfc374d">operator[]</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n)</td></tr>
<tr class="memdesc:af7bcf110b0944ec21ff21b763cfc374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element.  <a href="classcircular__queue.html#af7bcf110b0944ec21ff21b763cfc374d">More...</a><br /></td></tr>
<tr class="separator:af7bcf110b0944ec21ff21b763cfc374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1af026c379615b99e28904730369993"><td class="memItemLeft" align="right" valign="top"><a id="ad1af026c379615b99e28904730369993"></a>
<a class="el" href="classcircular__queue.html#a86954fc28d72c114c8e9d443c56b2a29">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ad1af026c379615b99e28904730369993">operator[]</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n) const</td></tr>
<tr class="memdesc:ad1af026c379615b99e28904730369993"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ad1af026c379615b99e28904730369993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to construct iterators to the container. </p>
</div></td></tr>
<tr class="memitem:a2871f6b985d41f3c5de71500d897bfcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd">begin</a> () noexcept</td></tr>
<tr class="memdesc:a2871f6b985d41f3c5de71500d897bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to beginning.  <a href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd">More...</a><br /></td></tr>
<tr class="separator:a2871f6b985d41f3c5de71500d897bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc55739815519917f854d16488e5b55e"><td class="memItemLeft" align="right" valign="top"><a id="acc55739815519917f854d16488e5b55e"></a>
<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#acc55739815519917f854d16488e5b55e">begin</a> () const noexcept</td></tr>
<tr class="memdesc:acc55739815519917f854d16488e5b55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:acc55739815519917f854d16488e5b55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141a9b6318c388bd4fcc155667304f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f">end</a> () noexcept</td></tr>
<tr class="memdesc:ad9141a9b6318c388bd4fcc155667304f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to end.  <a href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f">More...</a><br /></td></tr>
<tr class="separator:ad9141a9b6318c388bd4fcc155667304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7498e5ef1a8c8d2f9606de8afd0b7d"><td class="memItemLeft" align="right" valign="top"><a id="aee7498e5ef1a8c8d2f9606de8afd0b7d"></a>
<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aee7498e5ef1a8c8d2f9606de8afd0b7d">end</a> () const noexcept</td></tr>
<tr class="memdesc:aee7498e5ef1a8c8d2f9606de8afd0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aee7498e5ef1a8c8d2f9606de8afd0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c31d94f8ee4e128d0ae1f81c026cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#af27e91bd80e03de71446f52f85d22124">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af46c31d94f8ee4e128d0ae1f81c026cd">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:af46c31d94f8ee4e128d0ae1f81c026cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator to beginning.  <a href="classcircular__queue.html#af46c31d94f8ee4e128d0ae1f81c026cd">More...</a><br /></td></tr>
<tr class="separator:af46c31d94f8ee4e128d0ae1f81c026cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6d622f59fa571b277f0d268f720dec"><td class="memItemLeft" align="right" valign="top"><a id="a8c6d622f59fa571b277f0d268f720dec"></a>
<a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a8c6d622f59fa571b277f0d268f720dec">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8c6d622f59fa571b277f0d268f720dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a8c6d622f59fa571b277f0d268f720dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0460b144b85ccc94276b454f4e7478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#af27e91bd80e03de71446f52f85d22124">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a7a0460b144b85ccc94276b454f4e7478">rend</a> () noexcept</td></tr>
<tr class="memdesc:a7a0460b144b85ccc94276b454f4e7478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator to end.  <a href="classcircular__queue.html#a7a0460b144b85ccc94276b454f4e7478">More...</a><br /></td></tr>
<tr class="separator:a7a0460b144b85ccc94276b454f4e7478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765dda049ecf678a926b2b3f86b49e94"><td class="memItemLeft" align="right" valign="top"><a id="a765dda049ecf678a926b2b3f86b49e94"></a>
<a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a765dda049ecf678a926b2b3f86b49e94">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a765dda049ecf678a926b2b3f86b49e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a765dda049ecf678a926b2b3f86b49e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5064a6e8961e7958ab513d8622dd6dd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5064a6e8961e7958ab513d8622dd6dd4">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a5064a6e8961e7958ab513d8622dd6dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator to beginning.  <a href="classcircular__queue.html#a5064a6e8961e7958ab513d8622dd6dd4">More...</a><br /></td></tr>
<tr class="separator:a5064a6e8961e7958ab513d8622dd6dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856702e5d984a583eee6f2e21f75a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a4856702e5d984a583eee6f2e21f75a73">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a4856702e5d984a583eee6f2e21f75a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator to end.  <a href="classcircular__queue.html#a4856702e5d984a583eee6f2e21f75a73">More...</a><br /></td></tr>
<tr class="separator:a4856702e5d984a583eee6f2e21f75a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7e9e3192360771a7f6ed859fdf50d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5c7e9e3192360771a7f6ed859fdf50d8">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a5c7e9e3192360771a7f6ed859fdf50d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator to beginning.  <a href="classcircular__queue.html#a5c7e9e3192360771a7f6ed859fdf50d8">More...</a><br /></td></tr>
<tr class="separator:a5c7e9e3192360771a7f6ed859fdf50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac19b988e6dc51ea0b01d2e8e9694d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#adac19b988e6dc51ea0b01d2e8e9694d1">crend</a> () const noexcept</td></tr>
<tr class="memdesc:adac19b988e6dc51ea0b01d2e8e9694d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator to end.  <a href="classcircular__queue.html#adac19b988e6dc51ea0b01d2e8e9694d1">More...</a><br /></td></tr>
<tr class="separator:adac19b988e6dc51ea0b01d2e8e9694d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to determine the capacity of the container </p>
</div></td></tr>
<tr class="memitem:a21453b19a675e5fafee368b13d2f7f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a21453b19a675e5fafee368b13d2f7f73">size</a> () const noexcept</td></tr>
<tr class="memdesc:a21453b19a675e5fafee368b13d2f7f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size.  <a href="classcircular__queue.html#a21453b19a675e5fafee368b13d2f7f73">More...</a><br /></td></tr>
<tr class="separator:a21453b19a675e5fafee368b13d2f7f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c404ad53ccb54ad0b1a38c62c0b7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:af3c404ad53ccb54ad0b1a38c62c0b7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer capacity.  <a href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1">More...</a><br /></td></tr>
<tr class="separator:af3c404ad53ccb54ad0b1a38c62c0b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd8bcfe0774342b77bba0905e27f253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aefd8bcfe0774342b77bba0905e27f253">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aefd8bcfe0774342b77bba0905e27f253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum capacity.  <a href="classcircular__queue.html#aefd8bcfe0774342b77bba0905e27f253">More...</a><br /></td></tr>
<tr class="separator:aefd8bcfe0774342b77bba0905e27f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bfd609d417c1ae549356ef126b5931"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ae1bfd609d417c1ae549356ef126b5931">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ae1bfd609d417c1ae549356ef126b5931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether container is empty.  <a href="classcircular__queue.html#ae1bfd609d417c1ae549356ef126b5931">More...</a><br /></td></tr>
<tr class="separator:ae1bfd609d417c1ae549356ef126b5931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af140417eb4ea65176da23f3ad78b665e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af140417eb4ea65176da23f3ad78b665e">full</a> () const noexcept</td></tr>
<tr class="memdesc:af140417eb4ea65176da23f3ad78b665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether container is full.  <a href="classcircular__queue.html#af140417eb4ea65176da23f3ad78b665e">More...</a><br /></td></tr>
<tr class="separator:af140417eb4ea65176da23f3ad78b665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e12ec011b5002a27472a393e3d83a34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a4e12ec011b5002a27472a393e3d83a34">reserve</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n)</td></tr>
<tr class="memdesc:a4e12ec011b5002a27472a393e3d83a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a change in capacity.  <a href="classcircular__queue.html#a4e12ec011b5002a27472a393e3d83a34">More...</a><br /></td></tr>
<tr class="separator:a4e12ec011b5002a27472a393e3d83a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46337889e1f5deaca738e177df19c395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a46337889e1f5deaca738e177df19c395">resize</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val=<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a>())</td></tr>
<tr class="memdesc:a46337889e1f5deaca738e177df19c395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size.  <a href="classcircular__queue.html#a46337889e1f5deaca738e177df19c395">More...</a><br /></td></tr>
<tr class="separator:a46337889e1f5deaca738e177df19c395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584c831cc19c06332d72e48aa44843b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af584c831cc19c06332d72e48aa44843b">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:af584c831cc19c06332d72e48aa44843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink container to fit.  <a href="classcircular__queue.html#af584c831cc19c06332d72e48aa44843b">More...</a><br /></td></tr>
<tr class="separator:af584c831cc19c06332d72e48aa44843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element Access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Members that provide access to individual elements contained withing the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> </p>
</div></td></tr>
<tr class="memitem:ac679a5e48c66180ea2b6baa1af3b8595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ac679a5e48c66180ea2b6baa1af3b8595">at</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n)</td></tr>
<tr class="memdesc:ac679a5e48c66180ea2b6baa1af3b8595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element.  <a href="classcircular__queue.html#ac679a5e48c66180ea2b6baa1af3b8595">More...</a><br /></td></tr>
<tr class="separator:ac679a5e48c66180ea2b6baa1af3b8595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ac6cd169c64213f4dc93aadcda2dbd"><td class="memItemLeft" align="right" valign="top"><a id="ad4ac6cd169c64213f4dc93aadcda2dbd"></a>
<a class="el" href="classcircular__queue.html#a86954fc28d72c114c8e9d443c56b2a29">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ad4ac6cd169c64213f4dc93aadcda2dbd">at</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n) const</td></tr>
<tr class="memdesc:ad4ac6cd169c64213f4dc93aadcda2dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ad4ac6cd169c64213f4dc93aadcda2dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2c44b7e3f909f97da57f6f6ded8a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#abf2c44b7e3f909f97da57f6f6ded8a63">front</a> () noexcept</td></tr>
<tr class="memdesc:abf2c44b7e3f909f97da57f6f6ded8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element.  <a href="classcircular__queue.html#abf2c44b7e3f909f97da57f6f6ded8a63">More...</a><br /></td></tr>
<tr class="separator:abf2c44b7e3f909f97da57f6f6ded8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9b95858984ab6498e7d70fed73a35c"><td class="memItemLeft" align="right" valign="top"><a id="aba9b95858984ab6498e7d70fed73a35c"></a>
<a class="el" href="classcircular__queue.html#a86954fc28d72c114c8e9d443c56b2a29">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aba9b95858984ab6498e7d70fed73a35c">front</a> () const noexcept</td></tr>
<tr class="memdesc:aba9b95858984ab6498e7d70fed73a35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aba9b95858984ab6498e7d70fed73a35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a7506fcf86173805c1bfedb5f9c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a321a7506fcf86173805c1bfedb5f9c71">back</a> ()</td></tr>
<tr class="memdesc:a321a7506fcf86173805c1bfedb5f9c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element.  <a href="classcircular__queue.html#a321a7506fcf86173805c1bfedb5f9c71">More...</a><br /></td></tr>
<tr class="separator:a321a7506fcf86173805c1bfedb5f9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451fa321622a58c7d64799c025baa77"><td class="memItemLeft" align="right" valign="top"><a id="a5451fa321622a58c7d64799c025baa77"></a>
<a class="el" href="classcircular__queue.html#a86954fc28d72c114c8e9d443c56b2a29">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5451fa321622a58c7d64799c025baa77">back</a> () const</td></tr>
<tr class="memdesc:a5451fa321622a58c7d64799c025baa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a5451fa321622a58c7d64799c025baa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Member functions that modify the container. </p>
</div></td></tr>
<tr class="memitem:a84dcb0e84be01fd74dbad8d75d116b03"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a84dcb0e84be01fd74dbad8d75d116b03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a84dcb0e84be01fd74dbad8d75d116b03">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a84dcb0e84be01fd74dbad8d75d116b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container content range.  <a href="classcircular__queue.html#a84dcb0e84be01fd74dbad8d75d116b03">More...</a><br /></td></tr>
<tr class="separator:a84dcb0e84be01fd74dbad8d75d116b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94659dc2af601287cd60c75c360d63d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a94659dc2af601287cd60c75c360d63d6">assign</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a94659dc2af601287cd60c75c360d63d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container content by fill.  <a href="classcircular__queue.html#a94659dc2af601287cd60c75c360d63d6">More...</a><br /></td></tr>
<tr class="separator:a94659dc2af601287cd60c75c360d63d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dbdce81e8ebb7607bf32b11e7736f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a45dbdce81e8ebb7607bf32b11e7736f3">assign</a> (std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a45dbdce81e8ebb7607bf32b11e7736f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container contents from initializer list.  <a href="classcircular__queue.html#a45dbdce81e8ebb7607bf32b11e7736f3">More...</a><br /></td></tr>
<tr class="separator:a45dbdce81e8ebb7607bf32b11e7736f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaba0ad79ab49837a9d5f83da291012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aafaba0ad79ab49837a9d5f83da291012">clear</a> () noexcept</td></tr>
<tr class="memdesc:aafaba0ad79ab49837a9d5f83da291012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear content.  <a href="classcircular__queue.html#aafaba0ad79ab49837a9d5f83da291012">More...</a><br /></td></tr>
<tr class="separator:aafaba0ad79ab49837a9d5f83da291012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ab61a9304ffe9bddfa5488f4399bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc">push_back</a> (const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a210ab61a9304ffe9bddfa5488f4399bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at the end.  <a href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc">More...</a><br /></td></tr>
<tr class="separator:a210ab61a9304ffe9bddfa5488f4399bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ea92000265b7f84b5fda9b54359ff4"><td class="memItemLeft" align="right" valign="top"><a id="a14ea92000265b7f84b5fda9b54359ff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a14ea92000265b7f84b5fda9b54359ff4">push_back</a> (<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a14ea92000265b7f84b5fda9b54359ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a14ea92000265b7f84b5fda9b54359ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47686bfa34c8a6d48296559410ca3921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921">push_front</a> (const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a47686bfa34c8a6d48296559410ca3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at beginning.  <a href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921">More...</a><br /></td></tr>
<tr class="separator:a47686bfa34c8a6d48296559410ca3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12d8621bef3f3f850cbb45d86cb7b10"><td class="memItemLeft" align="right" valign="top"><a id="ac12d8621bef3f3f850cbb45d86cb7b10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ac12d8621bef3f3f850cbb45d86cb7b10">push_front</a> (<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ac12d8621bef3f3f850cbb45d86cb7b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ac12d8621bef3f3f850cbb45d86cb7b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5388dd06cc55b5000e7538838c084df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ab5388dd06cc55b5000e7538838c084df">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:ab5388dd06cc55b5000e7538838c084df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete last element.  <a href="classcircular__queue.html#ab5388dd06cc55b5000e7538838c084df">More...</a><br /></td></tr>
<tr class="separator:ab5388dd06cc55b5000e7538838c084df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9d128b3688087c01d262e5076120d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#abae9d128b3688087c01d262e5076120d">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:abae9d128b3688087c01d262e5076120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete first element.  <a href="classcircular__queue.html#abae9d128b3688087c01d262e5076120d">More...</a><br /></td></tr>
<tr class="separator:abae9d128b3688087c01d262e5076120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab325616178b504551bbf47b89de12c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ab325616178b504551bbf47b89de12c44">insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab325616178b504551bbf47b89de12c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (copy) single element.  <a href="classcircular__queue.html#ab325616178b504551bbf47b89de12c44">More...</a><br /></td></tr>
<tr class="separator:ab325616178b504551bbf47b89de12c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa579846ee08f4fbd19de6ddf3438c082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aa579846ee08f4fbd19de6ddf3438c082">insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:aa579846ee08f4fbd19de6ddf3438c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (move) single element.  <a href="classcircular__queue.html#aa579846ee08f4fbd19de6ddf3438c082">More...</a><br /></td></tr>
<tr class="separator:aa579846ee08f4fbd19de6ddf3438c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa193cbc95537ff05963ab6ee9eb6fdc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aa193cbc95537ff05963ab6ee9eb6fdc9">insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:aa193cbc95537ff05963ab6ee9eb6fdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (fill) elements.  <a href="classcircular__queue.html#aa193cbc95537ff05963ab6ee9eb6fdc9">More...</a><br /></td></tr>
<tr class="separator:aa193cbc95537ff05963ab6ee9eb6fdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a760fb00e78099900b5f8ed447e9c9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:af7a760fb00e78099900b5f8ed447e9c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af7a760fb00e78099900b5f8ed447e9c9">insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:af7a760fb00e78099900b5f8ed447e9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (range) elements.  <a href="classcircular__queue.html#af7a760fb00e78099900b5f8ed447e9c9">More...</a><br /></td></tr>
<tr class="separator:af7a760fb00e78099900b5f8ed447e9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452db4f7188d8bf76c989c7fbda670bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a452db4f7188d8bf76c989c7fbda670bf">insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a452db4f7188d8bf76c989c7fbda670bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements (initializer_list)  <a href="classcircular__queue.html#a452db4f7188d8bf76c989c7fbda670bf">More...</a><br /></td></tr>
<tr class="separator:a452db4f7188d8bf76c989c7fbda670bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688ece5ea70b64260ec6fbd52b45820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5688ece5ea70b64260ec6fbd52b45820">erase</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position)</td></tr>
<tr class="memdesc:a5688ece5ea70b64260ec6fbd52b45820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="classcircular__queue.html#a5688ece5ea70b64260ec6fbd52b45820">More...</a><br /></td></tr>
<tr class="separator:a5688ece5ea70b64260ec6fbd52b45820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8933a9b100ac3267af40a5f5771cefde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a8933a9b100ac3267af40a5f5771cefde">erase</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a8933a9b100ac3267af40a5f5771cefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements.  <a href="classcircular__queue.html#a8933a9b100ac3267af40a5f5771cefde">More...</a><br /></td></tr>
<tr class="separator:a8933a9b100ac3267af40a5f5771cefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7740220a997ddda8b97d21326da163a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a7740220a997ddda8b97d21326da163a6">swap</a> (<a class="el" href="classcircular__queue.html">circular_queue</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a7740220a997ddda8b97d21326da163a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content.  <a href="classcircular__queue.html#a7740220a997ddda8b97d21326da163a6">More...</a><br /></td></tr>
<tr class="separator:a7740220a997ddda8b97d21326da163a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cb2e3040e93b25f1c2c108010d0911"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac6cb2e3040e93b25f1c2c108010d0911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ac6cb2e3040e93b25f1c2c108010d0911">emplace</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac6cb2e3040e93b25f1c2c108010d0911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element.  <a href="classcircular__queue.html#ac6cb2e3040e93b25f1c2c108010d0911">More...</a><br /></td></tr>
<tr class="separator:ac6cb2e3040e93b25f1c2c108010d0911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a2445f675eb39b8676bcc92864613"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5b6a2445f675eb39b8676bcc92864613"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5b6a2445f675eb39b8676bcc92864613">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5b6a2445f675eb39b8676bcc92864613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element at beginning.  <a href="classcircular__queue.html#a5b6a2445f675eb39b8676bcc92864613">More...</a><br /></td></tr>
<tr class="separator:a5b6a2445f675eb39b8676bcc92864613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6448f39f9ebcd91010469b14dcf92e"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aba6448f39f9ebcd91010469b14dcf92e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aba6448f39f9ebcd91010469b14dcf92e">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aba6448f39f9ebcd91010469b14dcf92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element at the end.  <a href="classcircular__queue.html#aba6448f39f9ebcd91010469b14dcf92e">More...</a><br /></td></tr>
<tr class="separator:aba6448f39f9ebcd91010469b14dcf92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Access member objects of the container </p>
</div></td></tr>
<tr class="memitem:a3a2c594789b2faa1ed684e653b86718b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a3a2c594789b2faa1ed684e653b86718b">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a3a2c594789b2faa1ed684e653b86718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get allocator.  <a href="classcircular__queue.html#a3a2c594789b2faa1ed684e653b86718b">More...</a><br /></td></tr>
<tr class="separator:a3a2c594789b2faa1ed684e653b86718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5011a5b7bb4175600e4348ea32d43dcf"><td class="memTemplParams" colspan="2">template&lt;class copyFunctor &gt; </td></tr>
<tr class="memitem:a5011a5b7bb4175600e4348ea32d43dcf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5011a5b7bb4175600e4348ea32d43dcf">copy</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> last, <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> *destination, copyFunctor cf) const -&gt; decltype(cf((void *) destination,(void *) first.m_pointer.ptr,((last.m_pointer.ptr - first.m_pointer.ptr) *sizeof(<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a>))))</td></tr>
<tr class="memdesc:a5011a5b7bb4175600e4348ea32d43dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies range to destination buffer using provided copy function.  <a href="classcircular__queue.html#a5011a5b7bb4175600e4348ea32d43dcf">More...</a><br /></td></tr>
<tr class="separator:a5011a5b7bb4175600e4348ea32d43dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7cfa36abf3abc3f339ce045671eec507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a7cfa36abf3abc3f339ce045671eec507">increment</a> (<a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a> p, <a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a> n) const noexcept</td></tr>
<tr class="memdesc:a7cfa36abf3abc3f339ce045671eec507"><td class="mdescLeft">&#160;</td><td class="mdescRight">increments a pointer  <a href="classcircular__queue.html#a7cfa36abf3abc3f339ce045671eec507">More...</a><br /></td></tr>
<tr class="separator:a7cfa36abf3abc3f339ce045671eec507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a815c71bc6e056acfa577d3b9a13f"><td class="memItemLeft" align="right" valign="top"><a id="ab55a815c71bc6e056acfa577d3b9a13f"></a>
<a class="el" href="structcircular__queue_1_1const__queue__pointer.html">const_queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#ab55a815c71bc6e056acfa577d3b9a13f">increment</a> (<a class="el" href="structcircular__queue_1_1const__queue__pointer.html">const_queue_pointer</a> p, <a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a> n) const noexcept</td></tr>
<tr class="memdesc:ab55a815c71bc6e056acfa577d3b9a13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab55a815c71bc6e056acfa577d3b9a13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e88c681b7b7829549c6b6f52f51e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af47e88c681b7b7829549c6b6f52f51e6">decrement</a> (<a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a> p, <a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a> n) const noexcept</td></tr>
<tr class="memdesc:af47e88c681b7b7829549c6b6f52f51e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrements a pointer  <a href="classcircular__queue.html#af47e88c681b7b7829549c6b6f52f51e6">More...</a><br /></td></tr>
<tr class="separator:af47e88c681b7b7829549c6b6f52f51e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3b37f7b8acbbce961dca6c2adb40f3"><td class="memItemLeft" align="right" valign="top"><a id="a5a3b37f7b8acbbce961dca6c2adb40f3"></a>
<a class="el" href="structcircular__queue_1_1const__queue__pointer.html">const_queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a5a3b37f7b8acbbce961dca6c2adb40f3">decrement</a> (<a class="el" href="structcircular__queue_1_1const__queue__pointer.html">const_queue_pointer</a> p, <a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a> n, bool &amp;parity) const noexcept</td></tr>
<tr class="memdesc:a5a3b37f7b8acbbce961dca6c2adb40f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a5a3b37f7b8acbbce961dca6c2adb40f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c14efb10a585ecb37c7e22b332e845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a90c14efb10a585ecb37c7e22b332e845">reallocate</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n)</td></tr>
<tr class="memdesc:a90c14efb10a585ecb37c7e22b332e845"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves the currently contained data to a new area with size n.  <a href="classcircular__queue.html#a90c14efb10a585ecb37c7e22b332e845">More...</a><br /></td></tr>
<tr class="separator:a90c14efb10a585ecb37c7e22b332e845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e26f93c62855bb15b5a43d126bfaba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#af9e26f93c62855bb15b5a43d126bfaba">swapDownTo</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n) noexcept</td></tr>
<tr class="memdesc:af9e26f93c62855bb15b5a43d126bfaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the back of the queue down to position with elements n positions away.  <a href="classcircular__queue.html#af9e26f93c62855bb15b5a43d126bfaba">More...</a><br /></td></tr>
<tr class="separator:af9e26f93c62855bb15b5a43d126bfaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0abc37c1ada888c92ae27587353513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aef0abc37c1ada888c92ae27587353513">swapUpToEnd</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n) noexcept</td></tr>
<tr class="memdesc:aef0abc37c1ada888c92ae27587353513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given position to the end of the queue by successively swapping it.  <a href="classcircular__queue.html#aef0abc37c1ada888c92ae27587353513">More...</a><br /></td></tr>
<tr class="separator:aef0abc37c1ada888c92ae27587353513"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a88c42441dfd9a7bf3c85a898fbe67d7d"><td class="memItemLeft" align="right" valign="top"><a id="a88c42441dfd9a7bf3c85a898fbe67d7d"></a>
Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a88c42441dfd9a7bf3c85a898fbe67d7d">m_alloc</a></td></tr>
<tr class="memdesc:a88c42441dfd9a7bf3c85a898fbe67d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator class. NOT c-style malloc. <br /></td></tr>
<tr class="separator:a88c42441dfd9a7bf3c85a898fbe67d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59aff8995b0474c58d76445b81215d06"><td class="memItemLeft" align="right" valign="top"><a id="a59aff8995b0474c58d76445b81215d06"></a>
<a class="el" href="classcircular__queue.html#a4936ce8fe8200386264d1b81b805054d">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a59aff8995b0474c58d76445b81215d06">m_data</a></td></tr>
<tr class="memdesc:a59aff8995b0474c58d76445b81215d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the internal data array. <br /></td></tr>
<tr class="separator:a59aff8995b0474c58d76445b81215d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec3131755396afe7b25d451b1292ee9"><td class="memItemLeft" align="right" valign="top"><a id="afec3131755396afe7b25d451b1292ee9"></a>
<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#afec3131755396afe7b25d451b1292ee9">m_capacity</a></td></tr>
<tr class="memdesc:afec3131755396afe7b25d451b1292ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">capacity of the buffer array. <br /></td></tr>
<tr class="separator:afec3131755396afe7b25d451b1292ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1133152fe311405e79fecd4eed39bc"><td class="memItemLeft" align="right" valign="top"><a id="a3d1133152fe311405e79fecd4eed39bc"></a>
<a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#a3d1133152fe311405e79fecd4eed39bc">m_head</a></td></tr>
<tr class="memdesc:a3d1133152fe311405e79fecd4eed39bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the logical beginning of the buffer. No memory ownership! <br /></td></tr>
<tr class="separator:a3d1133152fe311405e79fecd4eed39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ea99d6dfb5829d78d7d219f8fc5eb"><td class="memItemLeft" align="right" valign="top"><a id="aa74ea99d6dfb5829d78d7d219f8fc5eb"></a>
<a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__queue.html#aa74ea99d6dfb5829d78d7d219f8fc5eb">m_tail</a></td></tr>
<tr class="memdesc:aa74ea99d6dfb5829d78d7d219f8fc5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the logical end of the buffer. No memory ownership! <br /></td></tr>
<tr class="separator:aa74ea99d6dfb5829d78d7d219f8fc5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class circular_queue&lt; T, Alloc &gt;</h3>

<p>Fixed capacity, STL-style, templated circular buffer. </p>
<p>see <a href="http://en.wikipedia.org/wiki/Circular_buffer">http://en.wikipedia.org/wiki/Circular_buffer</a> for details of how circular buffers work.<br  />
<br  />
 This implementation shares many features of a double-ended queue. This structure allows for the individual elements to be accessed directly through random access iterators, with storage handled automatically by over-writing elements from the opposite end of the container as it grows. As long as elements are added consistently to EITHER the front or the back, once full, the container will expand by over-writing the oldest element. If elements are added to both sides of the buffer, the behavior is effectively user defined.<br  />
<br  />
 Therefore, the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> provides a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. Also, like vectors (and unlike dequeues), all elements are stored in contiguous memory locations, and offset access IS allowed.<br  />
<br  />
 Both vectors and the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways : While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> are over-written once the buffer reaches its maximum capacity, ensuring elements are inserted and accessed in constant time and with a uniform sequential interface (through iterators), as opposed to the vector's amortized constant time. This allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocation's become more expensive, and real-time applications where stale data is not as useful as current data.<br  />
<br  />
 For operations that involve frequent insertion or removals of elements at positions other than the beginning or the end, circular_queues perform worse and have less consistent iterators and references than lists and forward lists.<br  />
<br  />
 This class can be moved very quickly (constant time). It may be slow to copy.<br  />
 <b>Container properties</b><br  />
 <em>Sequence</em><br  />
 Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence.<br  />
 <em>Fixed-capacity array</em><br  />
 Allows direct access to any element in the sequence and provides fast addition / removal of elements at the beginning or the end of the sequence.<br  />
 <em>Allocator - aware</em><br  />
 The container uses an allocator object to dynamically handle its storage needs.<br  />
 </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91892bdf329fea736011f0028444c90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91892bdf329fea736011f0028444c90d">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><b> Complexity:</b> O(N) with buffer capacity (memory allocation).<br  />
 <b> Iterator Validity:</b> N/A.<br  />
 <b> Data Races:</b> N/A.<br  />
 <b> Exception Safety:</b> Throws std::bad_alloc if allocation fails. In this case, no object is created.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>number of elements that can be stored in the queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef2e8bd3f0896605cf28c4c5e2898e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2e8bd3f0896605cf28c4c5e2898e8">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill constructor </p>
<p>Creates an array of size <em>capacity</em> and fills it with copies of <em>val</em>.<br  />
 <b> Complexity:</b> O(N) with size.<br  />
 <b> Iterator Validity:</b> N/A.<br  />
 <b> Data Races:</b> N/A.<br  />
 <b> Exception Safety:</b> Throws std::bad_alloc if allocation fails. In this case, no object is created.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>this value will be copied into all the container elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a501f5b60f6febaf29159de29b1ab67d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501f5b60f6febaf29159de29b1ab67d1">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_integral&lt; InputIterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range Constructor. </p>
<p>Creates a container by copying the objects in the range of the InputIterators [first, last). The size and capacity of the container will be equal to the size of the range.<br  />
 <b> Complexity:</b> O(N) with range.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> N/A.<br  />
 <b> Exception Safety:</b> Throws std::bad_alloc if allocation fails. In this case, no object is created.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the beginning of the range to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to the end (one past the last element) of the range to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2750feffc24a9db7a3f3a0aaf3407489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2750feffc24a9db7a3f3a0aaf3407489">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct from initializer list </p>
<p>constructs the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> by copying elements from the initializer_list. The size and capacity of the queue will be equal to the initializer_list size.<br  />
 <b> Complexity:</b> Linear with size of <em>il</em> (constructions).<br  />
 <b> Iterator Validity:</b> N/A.<br  />
 <b> Data Races:</b> N/A.<br  />
 <b> Exception Safety:</b> Throws std::bad_alloc if allocation fails. In this case, no object is created.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer_list object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac460f85ea9d2ea568a3ff1d8f622dece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460f85ea9d2ea568a3ff1d8f622dece">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<p>Creates a deep copy of another <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>.<br  />
 <b> Complexity:</b> O(N) with buffer capacity (memory allocation/copy).<br  />
 <b> Iterator Validity:</b> N/A.<br  />
 <b> Data Races:</b> N/A.<br  />
 <b> Exception Safety:</b> Throws std::bad_alloc if allocation fails. In this case, no object is created.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>buffer to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeccfb5d2b8f82f907c48b540fd9571e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccfb5d2b8f82f907c48b540fd9571e5">&#9670;&nbsp;</a></span>circular_queue() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<p>constructs a <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> and obtains its resources by moving them from another instance.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> All iterators to the other container are invalidated.<br  />
 <b> Data Races:</b> Container <em>other</em> is modified.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03bc81f048cd24f3879de76004399bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bc81f048cd24f3879de76004399bae">&#9670;&nbsp;</a></span>~circular_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::~<a class="el" href="classcircular__queue.html">circular_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<p>Yeah, you know what this is. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84dcb0e84be01fd74dbad8d75d116b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dcb0e84be01fd74dbad8d75d116b03">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container content range. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly.The new contents are elements constructed from each of the elements in the range between first and last, in the same order. The range used is [first, last).<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators are invalidated.<br  />
 <b> Data Races:</b> The container and all elements are modified. All copied elements are accessed.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if the range specified by [first,last) is not valid, it causes undefined behavior. Throws std::length_error if first == last.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>beginning of the range to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end (exclusive) of the range to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="a94659dc2af601287cd60c75c360d63d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94659dc2af601287cd60c75c360d63d6">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container content by fill. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly. The new contents are n elements, each initialized to a copy of val.<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references are invalidated.<br  />
 <b> Data Races:</b> The container and all elements are modified. All copied elements are accessed.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if the range specified by [first,last) is not valid, it causes undefined behavior. Throws std::length_error if first == last.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>new container size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to be copied into each element of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45dbdce81e8ebb7607bf32b11e7736f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dbdce81e8ebb7607bf32b11e7736f3">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container contents from initializer list. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly. The new contents are copies of the values passed as initializer list, in the same order.<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references related to this container are invalidated.<br  />
 <b> Data Races:</b> All copied elements are accessed. The container is modified. All contained elements are modified.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions it causes undefined behavior. If the initializer list is empty, std::length_error is thrown.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>An initializer_list object. The compiler will automatically construct such objects from initializer list declarators. Member type value_type is the type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="ac679a5e48c66180ea2b6baa1af3b8595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac679a5e48c66180ea2b6baa1af3b8595">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element. </p>
<p>Returns a reference to the element at position n in the container object. The function automatically checks whether n is within the bounds of valid elements in the container, throwing an out_of_range exception if it is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> .<br  />
 <b> Data Races:</b> .<br  />
 <b> Exception Safety:</b> .<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Position of an element in the container. If this is greater than the container size, an exception of type out_of_range is thrown. Notice that the first element has a position of 0 (not 1). Member type size_type is an unsigned integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the container. If the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> object is const-qualified, the function returns a const_reference. Otherwise, it returns a reference. </dd></dl>

</div>
</div>
<a id="a321a7506fcf86173805c1bfedb5f9c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a7506fcf86173805c1bfedb5f9c71">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access last element. </p>
<p>Returns a reference to the last element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>. Unlike member <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>, which returns an iterator just past this element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). The reference returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A reference to the last element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>. </dd></dl>

</div>
</div>
<a id="a2871f6b985d41f3c5de71500d897bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2871f6b985d41f3c5de71500d897bfcd">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator to beginning. </p>
<p>Returns an iterator to the head (first element) in the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="af3c404ad53ccb54ad0b1a38c62c0b7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c404ad53ccb54ad0b1a38c62c0b7f1">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get buffer capacity. </p>
<p>Returns the allocated size of the buffer. For the amount of the buffer in use, see <a class="el" href="classcircular__queue.html#a21453b19a675e5fafee368b13d2f7f73" title="Return size.">size()</a>.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container object is accessed.<br  />
 <b> Exception Safety:</b> No-throw guarantee: This function never throws exceptions.<br  />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a21453b19a675e5fafee368b13d2f7f73" title="Return size.">size()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>capacity of the buffer in terms of how many objects of <em>value_type</em> it can contain. </dd></dl>

</div>
</div>
<a id="a5064a6e8961e7958ab513d8622dd6dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5064a6e8961e7958ab513d8622dd6dd4">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator to beginning. </p>
<p>Returns a constant iterator to the head (first element) in the container. A <a class="el" href="classcircular__queue_1_1const__iterator.html" title="constant iterator for the circular_queue class.">const_iterator</a> is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the iterator returned by <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a>, but it cannot be used to modify the contents it points to, even if the container object is not itself const.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A constant iterator to the beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a4856702e5d984a583eee6f2e21f75a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4856702e5d984a583eee6f2e21f75a73">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator to end. </p>
<p>Returns a constant iterator to the tail (last element) in the container.A <a class="el" href="classcircular__queue_1_1const__iterator.html" title="constant iterator for the circular_queue class.">const_iterator</a> is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the iterator returned by <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a>, but it cannot be used to modify the contents it points to, even if the container object is not itself const.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A constant iterator to the end of the sequence container. </dd></dl>

</div>
</div>
<a id="aafaba0ad79ab49837a9d5f83da291012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaba0ad79ab49837a9d5f83da291012">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear content. </p>
<p>Removes all elements from the deque (which are destroyed), leaving the container with a size of 0.<br  />
 <b> Complexity:</b> Linear in size (destructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references related to this container are invalidated.<br  />
 <b> Data Races:</b> The container is modified. All contained elements are modified.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions.<br  />
</p>

</div>
</div>
<a id="a5011a5b7bb4175600e4348ea32d43dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5011a5b7bb4175600e4348ea32d43dcf">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class copyFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">copyFunctor&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; decltype(cf((void*) destination, (void*) first.m_pointer.ptr, ((last.m_pointer.ptr - first.m_pointer.ptr) * sizeof(<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a>))))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies range to destination buffer using provided copy function. </p>
<p>This function overloads memcpy to handle the internal complexities of copying a <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>, which may or may not be wrapped. The resulting array at destination will be unwrapped in either case, meaning logical and physical index[0] will always be the same. Since this function isn't allocator or iterator aware on the destination it's use should be avoided for EVERYTHING except compatibility with C code. In the author's opinion, the ONLY use case for this function is CUDA memory.<br  />
 <em>THIS MAY NOT WORK</em> if <em>value_type</em> does not exhibit bitwise copy semantics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first index to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to the last index to be copied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>output buffer where the data will be copied to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>functor used to perform the memory copy. Options may include memcpy, memmove, or bound versions of cudaMemcpy, cudaMemcpyAsync. Must have a signature of copyFunctor(void* destination, void* source, size_t sizeInBytesToCopy) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>forwards the return value of <em>copyFunctor</em>. </dd></dl>

</div>
</div>
<a id="a5c7e9e3192360771a7f6ed859fdf50d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7e9e3192360771a7f6ed859fdf50d8">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator to beginning. </p>
<p>Returns a reverse iterator to the reverse beginning (last element) in the container. crbegin points to the element right before the one that would be pointed to by <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>. A const_reverse_iterator is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the iterator returned by <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a>, but it cannot be used to modify the contents it points to, even if the container object is not itself const.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A constant iterator to the beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="adac19b988e6dc51ea0b01d2e8e9694d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac19b988e6dc51ea0b01d2e8e9694d1">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a318024c96f5b8a07404df79f29804288">const_reverse_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator to end. </p>
<p>Returns a reverse iterator pointing to the theoretical element preceding the first element in the container (which is considered its reverse end). A const_reverse_iterator is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the iterator returned by <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a>, but it cannot be used to modify the contents it points to, even if the object is not itself const.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A constant iterator to the end of the sequence container. </dd></dl>

</div>
</div>
<a id="af47e88c681b7b7829549c6b6f52f51e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47e88c681b7b7829549c6b6f52f51e6">&#9670;&nbsp;</a></span>decrement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::decrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decrements a pointer </p>
<p>Takes care of wrapping the pointer and keeping parity consistent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer to decrement. This function modifies the value of p. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements to increment the pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parity</td><td>parity bit associated with the pointer. This function modifies the value of parity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6cb2e3040e93b25f1c2c108010d0911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cb2e3040e93b25f1c2c108010d0911">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element. </p>
<p>The container is extended by inserting a new element at position. This new element is constructed in place using args as the arguments for its construction. This effectively increases the container size by one. Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers. See emplace_front and emplace_back for member functions that extend the container directly at the beginning or at the end. The element is constructed in-place by calling allocator_traits::construct with args forwarded.<br  />
 <b> Complexity:</b> Linear in the number of elements between <em>position</em> and <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>.<br  />
 <b> Iterator Validity:</b> All iterators, references, and pointers from <em>position</em> to <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is NOT safe to concurrently access or modify elements.<br  />
 <b> Exception Safety:</b> If position is end, there are no changes in the container in case of exception (strong guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee).<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new element is inserted. Member type <a class="el" href="classcircular__queue_1_1const__iterator.html" title="constant iterator for the circular_queue class.">const_iterator</a> is a random access iterator type that points to a constant element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments forwarded to construct the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a5b6a2445f675eb39b8676bcc92864613" title="Construct and insert element at beginning.">emplace_front()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#aba6448f39f9ebcd91010469b14dcf92e" title="Construct and insert element at the end.">emplace_back()</a> </dd></dl>

</div>
</div>
<a id="aba6448f39f9ebcd91010469b14dcf92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6448f39f9ebcd91010469b14dcf92e">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element at the end. </p>
<p>Inserts a new element at the end of the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>, right after its current last element. This new element is constructed in place using args as the arguments for its construction. This effectively increases the container capacity by one. The element is constructed in-place by calling allocator_traits::construct with args forwarded. A similar member function exists, push_back, which either copies or moves an existing object into the container.<br  />
 <b> Complexity:</b> Constant, if the contained object can be constructed in constant time.<br  />
 <b> Iterator Validity:</b> The end iterator is invalidated. If the container was full before the call, the begin iterator is also invalidated. All other iterators, pointers, and references remain valid.<br  />
 <b> Data Races:</b> The container is modified. If the container was full, the beginning element is destroyed. No other existing elements are accessed.<br  />
 <b> Exception Safety:</b> If the container is not full, there are no side effects (strong guarantee). Otherwise, if the function throws an exception, no resources are leaked (basic guarantee), however the head of the container will be destroyed even if emplace_back throws and no new object is added to the container.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to the constructor of the contained object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b6a2445f675eb39b8676bcc92864613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6a2445f675eb39b8676bcc92864613">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element at beginning. </p>
<p>Inserts a new element at the beginning of the container, right before its current first element. This new element is constructed in place using args as the arguments for its construction.This effectively increases the container size by one. The element is constructed in-place by calling allocator_traits::construct with args forwarded. A similar member function exists, push_front, which either copies or moves an existing object into the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> iterator is invalidated. If the container was full before the call, the end iterator is also invalidated. All other iterators, pointers, and references remain valid.<br  />
 <b> Data Races:</b> The container is modified. If the container was full, the last element is destroyed. No other existing elements are accessed.<br  />
 <b> Exception Safety:</b> If the container is not full, there are no side effects (strong guarantee). Otherwise, if the function throws an exception, no resources are leaked (basic guarantee), however the head of the container will be destroyed even if emplace_back throws and no new object is added to the container.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to the constructor of the contained object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1bfd609d417c1ae549356ef126b5931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bfd609d417c1ae549356ef126b5931">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether container is empty. </p>
<p>Returns whether the container is empty (i.e. whether its size is 0).<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container object is accessed, but no elements are accessed.<br  />
 <b> Exception Safety:</b> No-throw guarantee: This function never throws exceptions.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>true if the buffer is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="ad9141a9b6318c388bd4fcc155667304f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141a9b6318c388bd4fcc155667304f">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator to end. </p>
<p>Returns an iterator to the tail (last element) in the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the sequence container. </dd></dl>

</div>
</div>
<a id="a8933a9b100ac3267af40a5f5771cefde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8933a9b100ac3267af40a5f5771cefde">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements. </p>
<p>Removes from the deque container the range of elements ([<em>first</em>,<em>last</em>)). This effectively reduces the container size by the number of elements removed, which are destroyed.<br  />
 Double-ended queues are designed to be efficient removing (and inserting) elements at either the end or the beginning of the sequence. Removals on other positions are usually less efficient than in list or forward_list containers. <b> Complexity:</b> Linear in the distance from <em>position</em> to <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> times the number of elements erased.<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references to elements between <em>position</em> and <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> If the erasure happens at the end of the sequence, only the erased elements are modified. Otherwise it is not safe to access or modify elements.<br  />
 <b> Exception Safety:</b> If the removed elements include the the last element in the container, no exceptions are thrown (no-throw guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee): Copying or moving elements while relocating them may throw. Invalid ranges produce undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of range to erase from the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to one-past-last element of range to erase from the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="a5688ece5ea70b64260ec6fbd52b45820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5688ece5ea70b64260ec6fbd52b45820">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Removes from deque container a single element (<em>position</em>). This effectively reduces the container size by the number of elements removed, which are destroyed.<br  />
 Double-ended queues are designed to be efficient removing (and inserting) elements at either the end or the beginning of the sequence. Removals on other positions are usually less efficient than in list or forward_list containers. <b> Complexity:</b> Linear in the distance from <em>position</em> to <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>.<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references to elements between <em>position</em> and <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> If the erasure happens at the end of the sequence, only the erased elements are modified. Otherwise it is not safe to access or modify elements.<br  />
 <b> Exception Safety:</b> If the removed elements include the the last element in the container, no exceptions are thrown (no-throw guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee): Copying or moving elements while relocating them may throw. Invalid ranges produce undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Iterator pointing to a single element to be removed from the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="abf2c44b7e3f909f97da57f6f6ded8a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2c44b7e3f909f97da57f6f6ded8a63">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access first element. </p>
<p>Returns a reference to the first element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>. Unlike member <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a>, which returns an iterator to this same element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). The reference returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A reference to the first element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>. </dd></dl>

</div>
</div>
<a id="af140417eb4ea65176da23f3ad78b665e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af140417eb4ea65176da23f3ad78b665e">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether container is full. </p>
<p>Returns whether the container is empty (i.e. whether its size is equal to it's capacity).<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container object is accessed, but no elements are accessed.<br  />
 <b> Exception Safety:</b> .<br  />
</p><dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a3a2c594789b2faa1ed684e653b86718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2c594789b2faa1ed684e653b86718b">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a5731136205f641f6d4c9e10343c23a5a">allocator_type</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get allocator. </p>
<p>Returns a copy of the allocator object associated with the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed. No contained elements are accessed: concurrently accessing or modifying them is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. Copying any instantiation of the default allocator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>the allocator. </dd></dl>

</div>
</div>
<a id="a7cfa36abf3abc3f339ce045671eec507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfa36abf3abc3f339ce045671eec507">&#9670;&nbsp;</a></span>increment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcircular__queue_1_1queue__pointer.html">queue_pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#ab769df42cea6cf894a44007b33610ead">difference_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increments a pointer </p>
<p>Takes care of wrapping the pointer and keeping parity consistent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer to increment. This function modifies the value of p. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements to increment the pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parity</td><td>parity bit associated with the pointer. This function modifies the value of parity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab325616178b504551bbf47b89de12c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab325616178b504551bbf47b89de12c44">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (copy) single element. </p>
<p>The container is extended by inserting an element before the element at the specified position. This effectively increases the container size by 1. If the container is full, the element at <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> is overwritten. Makes at most 1 copy of val.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references from position to the end of the queue are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new elements are inserted. Iterator is a member type, defined as a random access iterator type that points to elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. Member type value_type is the type of the elements in the container, defined in deque as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted element. </dd></dl>

</div>
</div>
<a id="af7a760fb00e78099900b5f8ed447e9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a760fb00e78099900b5f8ed447e9c9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (range) elements. </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most <a class="el" href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1" title="Get buffer capacity.">capacity()</a> copies. The range of copied values is [first, last).<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of range to insert. InputIterator can be an iterator to any type of container, as long as it is at least a forward iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to one-past-end of range to insert. InputIterator can be an iterator to any type of container, as long as it is at least a forward iterator. type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="aa193cbc95537ff05963ab6ee9eb6fdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa193cbc95537ff05963ab6ee9eb6fdc9">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (fill) elements. </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most n copies of <em>val</em>.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> O(m*n) where m is the current size and m is the number of elements inserted.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of elements to insert. Each element is initialized to a copy of val. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied to the inserted elements. Member type value_type is the type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="a452db4f7188d8bf76c989c7fbda670bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452db4f7188d8bf76c989c7fbda670bf">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements (initializer_list) </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most <a class="el" href="classcircular__queue.html#af3c404ad53ccb54ad0b1a38c62c0b7f1" title="Get buffer capacity.">capacity()</a> copies.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer_list object, filled with values to insert into the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="aa579846ee08f4fbd19de6ddf3438c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa579846ee08f4fbd19de6ddf3438c082">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (move) single element. </p>
<p>The container is extended by inserting an element before the element at the specified position. This effectively increases the container size by 1. If the container is full, the element at <a class="el" href="classcircular__queue.html#a2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> is overwritten. Makes no copies of val, and val must be <em>move-assignable</em>.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references from position to the end of the queue are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new elements are inserted. Iterator is a member type, defined as a random access iterator type that points to elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. Member type value_type is the type of the elements in the container, defined in deque as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="classcircular__queue.html#a47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted element. </dd></dl>

</div>
</div>
<a id="aefd8bcfe0774342b77bba0905e27f253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8bcfe0774342b77bba0905e27f253">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum capacity. </p>
<p>Returns the maximum number of elements that the container can hold. This is the maximum potential capacity the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that capacity: it can still fail to allocate storage at any point before that capacity is reached.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed, but no contained elements are accessed. Concurrently accessing or modifying them is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: This function never throws exceptions.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>Maximum number of elements of type <em>value_type</em> that can be stored in the container. </dd></dl>

</div>
</div>
<a id="a66d679a6e39e5272ae77eb57df0fb764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d679a6e39e5272ae77eb57df0fb764">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&amp; <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content. </p>
<p>moves all the elements from <em>other</em> into the container (with <em>other</em> in an unspecified but valid state).<br  />
 <b> Complexity:</b> Linear in Size (destructions).<br  />
 <b> Iterator Validity:</b> All iterators, references and pointers related to this container before the call are invalidated.<br  />
 <b> Data Races:</b> All copied elements are accessed. The container and all its elements are modified.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if value_type is not move assignable, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__queue.html#a84dcb0e84be01fd74dbad8d75d116b03" title="Assign container content range.">assign()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a74e5626258e7a0e5e7530bd231857240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e5626258e7a0e5e7530bd231857240">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&amp; <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content. </p>
<p>copies all the elements from <em>other</em> into the container (with <em>other</em> preserving its contents).<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, copy constructions).<br  />
 <b> Iterator Validity:</b> All iterators, references and pointers related to this container before the call are invalidated.<br  />
 <b> Data Races:</b> All copied elements are accessed. The container and all its elements are modified.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if value_type is not copy assignable, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a1ac0bf2149c5f211dcf11e00c0b63bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac0bf2149c5f211dcf11e00c0b63bfa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html">circular_queue</a>&amp; <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. The new contents are copies of the values passed as initializer list, in the same order.<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators, references and pointers related to this container before the call are invalidated. <b> Data Races:</b> All copied elements are accessed. The container and all its elements are modified.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if value_type is not move assignable, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>&amp; </dd></dl>

</div>
</div>
<a id="af7bcf110b0944ec21ff21b763cfc374d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bcf110b0944ec21ff21b763cfc374d">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a6cdddd098481b69659d443474118ba0c">reference</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element. </p>
<p>Returns a reference to the element at position n in the container. A similar member function, <a class="el" href="classcircular__queue.html#ac679a5e48c66180ea2b6baa1af3b8595" title="Access element.">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classcircular__queue.html#ac679a5e48c66180ea2b6baa1af3b8595" title="Access element.">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception. Portable programs should never call this function with an argument n that is out of range, since this causes undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). The reference returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> If the container size is greater than n, the function never throws exceptions (no-throw guarantee). Otherwise, the behavior is undefined.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Position of an element in the container. Notice that the first element has a position of 0 (not 1). Member type size_type is an unsigned integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>. </dd></dl>

</div>
</div>
<a id="ab5388dd06cc55b5000e7538838c084df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5388dd06cc55b5000e7538838c084df">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete last element. </p>
<p>Removes the last element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> container, effectively reducing its size by one. This destroys the removed element. Popping an empty queue results in undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The iterators, pointers and references referring to the removed element are invalidated. Iterators, pointers and references referring to other elements that have not been removed are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. The last element is modified. Concurrently accessing or modifying other elements is safe (although see iterator validity above).<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior. </p>

</div>
</div>
<a id="abae9d128b3688087c01d262e5076120d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9d128b3688087c01d262e5076120d">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete first element. </p>
<p>Removes the first element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> container, effectively reducing its size by one. This destroys the removed element. Popping an empty queue results in undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The iterators, pointers and references referring to the removed element are invalidated. Iterators, pointers and references referring to other elements that have not been removed are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. The first element is modified. Concurrently accessing or modifying other elements is safe (although see iterator validity above).<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior. </p>

</div>
</div>
<a id="a210ab61a9304ffe9bddfa5488f4399bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ab61a9304ffe9bddfa5488f4399bc">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at the end. </p>
<p>Adds a new element at the end of the container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. If the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> is full, it will cause the element at the front of the queue to be overwritten.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> Only the end iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. If full, the first element in the queue is modified. Concurrently accessing or modifying other elements is safe.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If the element is copyable or no-throw movable, then there are no side effects (strong guarantee). If the container is not full, then there are no side effects (strong guarantee). If the container is full, and an exception occurs, the first element in the container will be destroyed. If allocator_traits::construct is not supported with val as argument, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to copy/move into the end of the container. Member type value_type is the type of the elements in the container, defined in vector as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47686bfa34c8a6d48296559410ca3921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47686bfa34c8a6d48296559410ca3921">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at beginning. </p>
<p>Adds a new element at the beginning of the container, right before its current first element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. If the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> is full, it will cause the element at the end of the queue to be overwritten.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> Only the begin iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. If full, the last element in the queue is modified. Concurrently accessing or modifying other elements is safe.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If the element is copyable or no-throw movable, then there are no side effects (strong guarantee). If allocator_traits::construct is not supported with val as argument, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to copy/move into the end of the container. Member type value_type is the type of the elements in the container, defined in vector as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af46c31d94f8ee4e128d0ae1f81c026cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46c31d94f8ee4e128d0ae1f81c026cd">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#af27e91bd80e03de71446f52f85d22124">reverse_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reverse iterator to beginning. </p>
<p>@function rbegin</p>
<p>Returns a reverse iterator to the reverse beginning (last element) in the container. rbegin points to the element right before the one that would be pointed to by <a class="el" href="classcircular__queue.html#ad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a90c14efb10a585ecb37c7e22b332e845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c14efb10a585ecb37c7e22b332e845">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moves the currently contained data to a new area with size n. </p>
<p>O(n) complexity. Unwraps the buffer as a side effect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of new allocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a0460b144b85ccc94276b454f4e7478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0460b144b85ccc94276b454f4e7478">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#af27e91bd80e03de71446f52f85d22124">reverse_iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reverse iterator to end. </p>
<p>Returns a reverse iterator pointing to the theoretical element preceding the first element in the container (which is considered its reverse end).<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed (neither the const nor the non-const versions modify the container). No contained elements are accessed by the call, but the iterator returned can be used to access or modify elements. Concurrently accessing or modifying different elements is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions. The copy construction or assignment of the returned iterator is also guaranteed to never throw.<br  />
</p><dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the end of the sequence container. </dd></dl>

</div>
</div>
<a id="a4e12ec011b5002a27472a393e3d83a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e12ec011b5002a27472a393e3d83a34">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a change in capacity. </p>
<p>Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current capacity, the function causes the container to reallocate its storage increasing its capacity to n. In all other cases, the function call does not cause a reallocation and the vector capacity is not affected.<br  />
 <b> Complexity:</b> If a reallocation happens, linear in size at most..<br  />
 <b> Iterator Validity:</b> If a reallocation happens, all iterators, pointers and references related to the container are invalidated. Otherwise, they all keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> If a reallocation happens, the container and all its contained elements are modified.<br  />
 <b> Exception Safety:</b> If no reallocations happen or if the type of the elements has either a non-throwing move constructor or a copy constructor, there are no changes in the container in case of exception (strong guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee). Under the basic guarantee, if this function throws, it's possible that all the container contents will be destroyed as a side-effect. The function throws bad_alloc if it fails to allocate the new size.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Minimum capacity for the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46337889e1f5deaca738e177df19c395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46337889e1f5deaca738e177df19c395">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code><a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size. </p>
<p>Changes <em>both</em> the size and capacity of the container, resizing the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. Regardless of the value of n (except n == <a class="el" href="classcircular__queue.html#a21453b19a675e5fafee368b13d2f7f73" title="Return size.">size()</a>), an automatic reallocation of the allocated storage space takes place. Notice that this function changes the actual content of the container by inserting or erasing elements from it.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted/erased (constructions/destructions). If a reallocation happens, the reallocation is itself up to linear in the entire container size.<br  />
 <b> Iterator Validity:</b> Resizing causes reallocation, and so all iterators, pointers and references related to this container are also invalidated.<br  />
 <b> Data Races:</b> The container is modified. If a reallocation happens, all contained elements are modified.<br  />
 <b> Exception Safety:</b> If n is less than or equal to the size of the container, the function never throws exceptions (no-throw guarantee). If n is greater and a reallocation happens, there are no changes in the container in case of exception (strong guarantee) if the type of the elements is either copyable or no-throw movable. Otherwise, if an exception is thrown, the container is left with a valid state (basic guarantee).<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New container size, expressed in number of elements. Member type <em>size_type</em> is an unsigned integral type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Object whose content is copied to the added elements in case that n is greater than the current container size. If not specified, the default constructor is used instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af584c831cc19c06332d72e48aa44843b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af584c831cc19c06332d72e48aa44843b">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrink container to fit. </p>
<p>Requests the container to reduce its capacity to fit its size. Unlike vector, the request is binding. This will never cause a reallocation, and has no effect on the size or element contents.<br  />
 <b> Complexity:</b> At most, linear in container size..<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references related to the container are invalidated.<br  />
 <b> Data Races:</b> The container is modified. All contained objects are moved.<br  />
 <b> Exception Safety:</b> If the type of the elements is either copyable or no-throw movable, there are no changes in the container in case of exception (strong guarantee). Otherwise, if an exception is thrown, the container is left with a valid state (basic guarantee).<br  />
</p>

</div>
</div>
<a id="a21453b19a675e5fafee368b13d2f7f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21453b19a675e5fafee368b13d2f7f73">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size. </p>
<p>Returns the number of elements in the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> No changes.<br  />
 <b> Data Races:</b> The container is accessed. No contained elements are accessed: concurrently accessing or modifying them is safe.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions..<br  />
</p><dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. Member type size_type is an unsigned integral type. </dd></dl>

</div>
</div>
<a id="a7740220a997ddda8b97d21326da163a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7740220a997ddda8b97d21326da163a6">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content. </p>
<p>Exchanges the content of the container by the content of <em>other</em>, which is another <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> object containing elements of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in <em>other</em> before the call, and the elements of <em>other</em> are those which were in <em>this</em>. All iterators, references and pointers remain valid for the swapped objects. Notice that a non-member function exists with the same name, swap, overloading that algorithm with an optimization that behaves like this member function.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references referring to elements in both containers remain valid, and are now referring to the same elements they referred to before the call, but in the other container, where they now iterate.<br  />
 <b> Data Races:</b> Both the container and <em>other</em> are modified. No contained elements are accessed by the call.<br  />
 <b> Exception Safety:</b> If the allocators in both containers compare equal, or if their allocator traits indicate that the allocators shall propagate, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to swap with <em>this</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9e26f93c62855bb15b5a43d126bfaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e26f93c62855bb15b5a43d126bfaba">&#9670;&nbsp;</a></span>swapDownTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::swapDownTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the back of the queue down to position with elements n positions away. </p>
<p>No-throw. O(n) complexity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>position to swap down to from the end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to position of last element swapped. </dd></dl>

</div>
</div>
<a id="aef0abc37c1ada888c92ae27587353513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0abc37c1ada888c92ae27587353513">&#9670;&nbsp;</a></span>swapUpToEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::swapUpToEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given position to the end of the queue by successively swapping it. </p>
<p>No-throw. O(n) complexity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>position to swap up to the end from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to position of first element swapped. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="circular__queue_8h_source.html">circular_queue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classcircular__queue.html">circular_queue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
