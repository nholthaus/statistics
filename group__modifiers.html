<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Queue: Modifiers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Queue
   </div>
   <div id="projectbrief">A C++17 Library of various `queue` containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__modifiers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Modifiers</div>  </div>
</div><!--header-->
<div class="contents">

<p>Member functions that modify the container.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga84dcb0e84be01fd74dbad8d75d116b03"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ga84dcb0e84be01fd74dbad8d75d116b03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga84dcb0e84be01fd74dbad8d75d116b03">circular_queue&lt; T, Alloc &gt;::assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ga84dcb0e84be01fd74dbad8d75d116b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container content range.  <a href="group__modifiers.html#ga84dcb0e84be01fd74dbad8d75d116b03">More...</a><br /></td></tr>
<tr class="separator:ga84dcb0e84be01fd74dbad8d75d116b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94659dc2af601287cd60c75c360d63d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga94659dc2af601287cd60c75c360d63d6">circular_queue&lt; T, Alloc &gt;::assign</a> (<a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ga94659dc2af601287cd60c75c360d63d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container content by fill.  <a href="group__modifiers.html#ga94659dc2af601287cd60c75c360d63d6">More...</a><br /></td></tr>
<tr class="separator:ga94659dc2af601287cd60c75c360d63d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dbdce81e8ebb7607bf32b11e7736f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga45dbdce81e8ebb7607bf32b11e7736f3">circular_queue&lt; T, Alloc &gt;::assign</a> (std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:ga45dbdce81e8ebb7607bf32b11e7736f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign container contents from initializer list.  <a href="group__modifiers.html#ga45dbdce81e8ebb7607bf32b11e7736f3">More...</a><br /></td></tr>
<tr class="separator:ga45dbdce81e8ebb7607bf32b11e7736f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafaba0ad79ab49837a9d5f83da291012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gaafaba0ad79ab49837a9d5f83da291012">circular_queue&lt; T, Alloc &gt;::clear</a> () noexcept</td></tr>
<tr class="memdesc:gaafaba0ad79ab49837a9d5f83da291012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear content.  <a href="group__modifiers.html#gaafaba0ad79ab49837a9d5f83da291012">More...</a><br /></td></tr>
<tr class="separator:gaafaba0ad79ab49837a9d5f83da291012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5388dd06cc55b5000e7538838c084df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gab5388dd06cc55b5000e7538838c084df">circular_queue&lt; T, Alloc &gt;::pop_back</a> () noexcept</td></tr>
<tr class="memdesc:gab5388dd06cc55b5000e7538838c084df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete last element.  <a href="group__modifiers.html#gab5388dd06cc55b5000e7538838c084df">More...</a><br /></td></tr>
<tr class="separator:gab5388dd06cc55b5000e7538838c084df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae9d128b3688087c01d262e5076120d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gabae9d128b3688087c01d262e5076120d">circular_queue&lt; T, Alloc &gt;::pop_front</a> () noexcept</td></tr>
<tr class="memdesc:gabae9d128b3688087c01d262e5076120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete first element.  <a href="group__modifiers.html#gabae9d128b3688087c01d262e5076120d">More...</a><br /></td></tr>
<tr class="separator:gabae9d128b3688087c01d262e5076120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab325616178b504551bbf47b89de12c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gab325616178b504551bbf47b89de12c44">circular_queue&lt; T, Alloc &gt;::insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:gab325616178b504551bbf47b89de12c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (copy) single element.  <a href="group__modifiers.html#gab325616178b504551bbf47b89de12c44">More...</a><br /></td></tr>
<tr class="separator:gab325616178b504551bbf47b89de12c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa579846ee08f4fbd19de6ddf3438c082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gaa579846ee08f4fbd19de6ddf3438c082">circular_queue&lt; T, Alloc &gt;::insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:gaa579846ee08f4fbd19de6ddf3438c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (move) single element.  <a href="group__modifiers.html#gaa579846ee08f4fbd19de6ddf3438c082">More...</a><br /></td></tr>
<tr class="separator:gaa579846ee08f4fbd19de6ddf3438c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa193cbc95537ff05963ab6ee9eb6fdc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gaa193cbc95537ff05963ab6ee9eb6fdc9">circular_queue&lt; T, Alloc &gt;::insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, <a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a> n, const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:gaa193cbc95537ff05963ab6ee9eb6fdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (fill) elements.  <a href="group__modifiers.html#gaa193cbc95537ff05963ab6ee9eb6fdc9">More...</a><br /></td></tr>
<tr class="separator:gaa193cbc95537ff05963ab6ee9eb6fdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a760fb00e78099900b5f8ed447e9c9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:gaf7a760fb00e78099900b5f8ed447e9c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gaf7a760fb00e78099900b5f8ed447e9c9">circular_queue&lt; T, Alloc &gt;::insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:gaf7a760fb00e78099900b5f8ed447e9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (range) elements.  <a href="group__modifiers.html#gaf7a760fb00e78099900b5f8ed447e9c9">More...</a><br /></td></tr>
<tr class="separator:gaf7a760fb00e78099900b5f8ed447e9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452db4f7188d8bf76c989c7fbda670bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga452db4f7188d8bf76c989c7fbda670bf">circular_queue&lt; T, Alloc &gt;::insert</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:ga452db4f7188d8bf76c989c7fbda670bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements (initializer_list)  <a href="group__modifiers.html#ga452db4f7188d8bf76c989c7fbda670bf">More...</a><br /></td></tr>
<tr class="separator:ga452db4f7188d8bf76c989c7fbda670bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5688ece5ea70b64260ec6fbd52b45820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga5688ece5ea70b64260ec6fbd52b45820">circular_queue&lt; T, Alloc &gt;::erase</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position)</td></tr>
<tr class="memdesc:ga5688ece5ea70b64260ec6fbd52b45820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="group__modifiers.html#ga5688ece5ea70b64260ec6fbd52b45820">More...</a><br /></td></tr>
<tr class="separator:ga5688ece5ea70b64260ec6fbd52b45820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8933a9b100ac3267af40a5f5771cefde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga8933a9b100ac3267af40a5f5771cefde">circular_queue&lt; T, Alloc &gt;::erase</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:ga8933a9b100ac3267af40a5f5771cefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements.  <a href="group__modifiers.html#ga8933a9b100ac3267af40a5f5771cefde">More...</a><br /></td></tr>
<tr class="separator:ga8933a9b100ac3267af40a5f5771cefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7740220a997ddda8b97d21326da163a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga7740220a997ddda8b97d21326da163a6">circular_queue&lt; T, Alloc &gt;::swap</a> (<a class="el" href="classcircular__queue.html">circular_queue</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ga7740220a997ddda8b97d21326da163a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content.  <a href="group__modifiers.html#ga7740220a997ddda8b97d21326da163a6">More...</a><br /></td></tr>
<tr class="separator:ga7740220a997ddda8b97d21326da163a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cb2e3040e93b25f1c2c108010d0911"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:gac6cb2e3040e93b25f1c2c108010d0911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gac6cb2e3040e93b25f1c2c108010d0911">circular_queue&lt; T, Alloc &gt;::emplace</a> (<a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a> position, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gac6cb2e3040e93b25f1c2c108010d0911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element.  <a href="group__modifiers.html#gac6cb2e3040e93b25f1c2c108010d0911">More...</a><br /></td></tr>
<tr class="separator:gac6cb2e3040e93b25f1c2c108010d0911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6a2445f675eb39b8676bcc92864613"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ga5b6a2445f675eb39b8676bcc92864613"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga5b6a2445f675eb39b8676bcc92864613">circular_queue&lt; T, Alloc &gt;::emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga5b6a2445f675eb39b8676bcc92864613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element at beginning.  <a href="group__modifiers.html#ga5b6a2445f675eb39b8676bcc92864613">More...</a><br /></td></tr>
<tr class="separator:ga5b6a2445f675eb39b8676bcc92864613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6448f39f9ebcd91010469b14dcf92e"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:gaba6448f39f9ebcd91010469b14dcf92e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifiers.html#gaba6448f39f9ebcd91010469b14dcf92e">circular_queue&lt; T, Alloc &gt;::emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaba6448f39f9ebcd91010469b14dcf92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element at the end.  <a href="group__modifiers.html#gaba6448f39f9ebcd91010469b14dcf92e">More...</a><br /></td></tr>
<tr class="separator:gaba6448f39f9ebcd91010469b14dcf92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210ab61a9304ffe9bddfa5488f4399bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc">circular_queue&lt; T, Alloc &gt;::push_back</a> (const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ga210ab61a9304ffe9bddfa5488f4399bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at the end.  <a href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc">More...</a><br /></td></tr>
<tr class="separator:ga210ab61a9304ffe9bddfa5488f4399bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ea92000265b7f84b5fda9b54359ff4"><td class="memItemLeft" align="right" valign="top"><a id="ga14ea92000265b7f84b5fda9b54359ff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>circular_queue&lt; T, Alloc &gt;::push_back</b> (<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="separator:ga14ea92000265b7f84b5fda9b54359ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47686bfa34c8a6d48296559410ca3921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921">circular_queue&lt; T, Alloc &gt;::push_front</a> (const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ga47686bfa34c8a6d48296559410ca3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at beginning.  <a href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921">More...</a><br /></td></tr>
<tr class="separator:ga47686bfa34c8a6d48296559410ca3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12d8621bef3f3f850cbb45d86cb7b10"><td class="memItemLeft" align="right" valign="top"><a id="gac12d8621bef3f3f850cbb45d86cb7b10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>circular_queue&lt; T, Alloc &gt;::push_front</b> (<a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;val)</td></tr>
<tr class="separator:gac12d8621bef3f3f850cbb45d86cb7b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Member functions that modify the container. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga84dcb0e84be01fd74dbad8d75d116b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84dcb0e84be01fd74dbad8d75d116b03">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container content range. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly.The new contents are elements constructed from each of the elements in the range between first and last, in the same order. The range used is [first, last).<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators are invalidated.<br  />
 <b> Data Races:</b> The container and all elements are modified. All copied elements are accessed.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if the range specified by [first,last) is not valid, it causes undefined behavior. Throws std::length_error if first == last.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>beginning of the range to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end (exclusive) of the range to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="ga94659dc2af601287cd60c75c360d63d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94659dc2af601287cd60c75c360d63d6">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container content by fill. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly. The new contents are n elements, each initialized to a copy of val.<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references are invalidated.<br  />
 <b> Data Races:</b> The container and all elements are modified. All copied elements are accessed.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if the range specified by [first,last) is not valid, it causes undefined behavior. Throws std::length_error if first == last.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>new container size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to be copied into each element of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45dbdce81e8ebb7607bf32b11e7736f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45dbdce81e8ebb7607bf32b11e7736f3">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign container contents from initializer list. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size and capacity accordingly. The new contents are copies of the values passed as initializer list, in the same order.<br  />
 <b> Complexity:</b> Linear in initial and final sizes (destructions, constructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references related to this container are invalidated.<br  />
 <b> Data Races:</b> All copied elements are accessed. The container is modified. All contained elements are modified.<br  />
 <b> Exception Safety:</b> Basic guarantee: if an exception is thrown, the container is in a valid state. If allocator_traits::construct is not supported with the appropriate arguments for the element constructions it causes undefined behavior. If the initializer list is empty, std::length_error is thrown.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>An initializer_list object. The compiler will automatically construct such objects from initializer list declarators. Member type value_type is the type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="gaafaba0ad79ab49837a9d5f83da291012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafaba0ad79ab49837a9d5f83da291012">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear content. </p>
<p>Removes all elements from the deque (which are destroyed), leaving the container with a size of 0.<br  />
 <b> Complexity:</b> Linear in size (destructions).<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references related to this container are invalidated.<br  />
 <b> Data Races:</b> The container is modified. All contained elements are modified.<br  />
 <b> Exception Safety:</b> No-throw guarantee: this member function never throws exceptions.<br  />
</p>

</div>
</div>
<a id="gac6cb2e3040e93b25f1c2c108010d0911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6cb2e3040e93b25f1c2c108010d0911">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element. </p>
<p>The container is extended by inserting a new element at position. This new element is constructed in place using args as the arguments for its construction. This effectively increases the container size by one. Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers. See emplace_front and emplace_back for member functions that extend the container directly at the beginning or at the end. The element is constructed in-place by calling allocator_traits::construct with args forwarded.<br  />
 <b> Complexity:</b> Linear in the number of elements between <em>position</em> and <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>.<br  />
 <b> Iterator Validity:</b> All iterators, references, and pointers from <em>position</em> to <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is NOT safe to concurrently access or modify elements.<br  />
 <b> Exception Safety:</b> If position is end, there are no changes in the container in case of exception (strong guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee).<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new element is inserted. Member type <a class="el" href="classcircular__queue_1_1const__iterator.html" title="constant iterator for the circular_queue class.">const_iterator</a> is a random access iterator type that points to a constant element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments forwarded to construct the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga5b6a2445f675eb39b8676bcc92864613" title="Construct and insert element at beginning.">emplace_front()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#gaba6448f39f9ebcd91010469b14dcf92e" title="Construct and insert element at the end.">emplace_back()</a> </dd></dl>

</div>
</div>
<a id="gaba6448f39f9ebcd91010469b14dcf92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba6448f39f9ebcd91010469b14dcf92e">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element at the end. </p>
<p>Inserts a new element at the end of the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a>, right after its current last element. This new element is constructed in place using args as the arguments for its construction. This effectively increases the container capacity by one. The element is constructed in-place by calling allocator_traits::construct with args forwarded. A similar member function exists, push_back, which either copies or moves an existing object into the container.<br  />
 <b> Complexity:</b> Constant, if the contained object can be constructed in constant time.<br  />
 <b> Iterator Validity:</b> The end iterator is invalidated. If the container was full before the call, the begin iterator is also invalidated. All other iterators, pointers, and references remain valid.<br  />
 <b> Data Races:</b> The container is modified. If the container was full, the beginning element is destroyed. No other existing elements are accessed.<br  />
 <b> Exception Safety:</b> If the container is not full, there are no side effects (strong guarantee). Otherwise, if the function throws an exception, no resources are leaked (basic guarantee), however the head of the container will be destroyed even if emplace_back throws and no new object is added to the container.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to the constructor of the contained object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b6a2445f675eb39b8676bcc92864613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b6a2445f675eb39b8676bcc92864613">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and insert element at beginning. </p>
<p>Inserts a new element at the beginning of the container, right before its current first element. This new element is constructed in place using args as the arguments for its construction.This effectively increases the container size by one. The element is constructed in-place by calling allocator_traits::construct with args forwarded. A similar member function exists, push_front, which either copies or moves an existing object into the container.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The <a class="el" href="group__iterators.html#ga2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> iterator is invalidated. If the container was full before the call, the end iterator is also invalidated. All other iterators, pointers, and references remain valid.<br  />
 <b> Data Races:</b> The container is modified. If the container was full, the last element is destroyed. No other existing elements are accessed.<br  />
 <b> Exception Safety:</b> If the container is not full, there are no side effects (strong guarantee). Otherwise, if the function throws an exception, no resources are leaked (basic guarantee), however the head of the container will be destroyed even if emplace_back throws and no new object is added to the container.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to the constructor of the contained object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8933a9b100ac3267af40a5f5771cefde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8933a9b100ac3267af40a5f5771cefde">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements. </p>
<p>Removes from the deque container the range of elements ([<em>first</em>,<em>last</em>)). This effectively reduces the container size by the number of elements removed, which are destroyed.<br  />
 Double-ended queues are designed to be efficient removing (and inserting) elements at either the end or the beginning of the sequence. Removals on other positions are usually less efficient than in list or forward_list containers. <b> Complexity:</b> Linear in the distance from <em>position</em> to <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> times the number of elements erased.<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references to elements between <em>position</em> and <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> If the erasure happens at the end of the sequence, only the erased elements are modified. Otherwise it is not safe to access or modify elements.<br  />
 <b> Exception Safety:</b> If the removed elements include the the last element in the container, no exceptions are thrown (no-throw guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee): Copying or moving elements while relocating them may throw. Invalid ranges produce undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of range to erase from the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to one-past-last element of range to erase from the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="ga5688ece5ea70b64260ec6fbd52b45820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5688ece5ea70b64260ec6fbd52b45820">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Removes from deque container a single element (<em>position</em>). This effectively reduces the container size by the number of elements removed, which are destroyed.<br  />
 Double-ended queues are designed to be efficient removing (and inserting) elements at either the end or the beginning of the sequence. Removals on other positions are usually less efficient than in list or forward_list containers. <b> Complexity:</b> Linear in the distance from <em>position</em> to <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a>.<br  />
 <b> Iterator Validity:</b> All iterators, pointers, and references to elements between <em>position</em> and <a class="el" href="group__iterators.html#gad9141a9b6318c388bd4fcc155667304f" title="Returns iterator to end.">end()</a> are invalidated.<br  />
 <b> Data Races:</b> If the erasure happens at the end of the sequence, only the erased elements are modified. Otherwise it is not safe to access or modify elements.<br  />
 <b> Exception Safety:</b> If the removed elements include the the last element in the container, no exceptions are thrown (no-throw guarantee). Otherwise, the container is guaranteed to end in a valid state (basic guarantee): Copying or moving elements while relocating them may throw. Invalid ranges produce undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Iterator pointing to a single element to be removed from the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="gab325616178b504551bbf47b89de12c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab325616178b504551bbf47b89de12c44">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (copy) single element. </p>
<p>The container is extended by inserting an element before the element at the specified position. This effectively increases the container size by 1. If the container is full, the element at <a class="el" href="group__iterators.html#ga2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> is overwritten. Makes at most 1 copy of val.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references from position to the end of the queue are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new elements are inserted. Iterator is a member type, defined as a random access iterator type that points to elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. Member type value_type is the type of the elements in the container, defined in deque as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted element. </dd></dl>

</div>
</div>
<a id="gaf7a760fb00e78099900b5f8ed447e9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a760fb00e78099900b5f8ed447e9c9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (range) elements. </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most <a class="el" href="group__capacity.html#gaf3c404ad53ccb54ad0b1a38c62c0b7f1" title="Get buffer capacity.">capacity()</a> copies. The range of copied values is [first, last).<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of range to insert. InputIterator can be an iterator to any type of container, as long as it is at least a forward iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to one-past-end of range to insert. InputIterator can be an iterator to any type of container, as long as it is at least a forward iterator. type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="gaa193cbc95537ff05963ab6ee9eb6fdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa193cbc95537ff05963ab6ee9eb6fdc9">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#a7304fc81b0bc9d7ec76da67a4f718de4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (fill) elements. </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most n copies of <em>val</em>.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> O(m*n) where m is the current size and m is the number of elements inserted.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of elements to insert. Each element is initialized to a copy of val. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied to the inserted elements. Member type value_type is the type of the elements in the container, defined in <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="ga452db4f7188d8bf76c989c7fbda670bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga452db4f7188d8bf76c989c7fbda670bf">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements (initializer_list) </p>
<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the container size by the amount of elements inserted. If this size is greater than the current capacity, the elements at the beginning of the queue will be over-written. This operation will cause at most <a class="el" href="group__capacity.html#gaf3c404ad53ccb54ad0b1a38c62c0b7f1" title="Get buffer capacity.">capacity()</a> copies.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the fill will be inserted before the element at this position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer_list object, filled with values to insert into the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="gaa579846ee08f4fbd19de6ddf3438c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa579846ee08f4fbd19de6ddf3438c082">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__queue_1_1iterator.html">iterator</a> <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert (move) single element. </p>
<p>The container is extended by inserting an element before the element at the specified position. This effectively increases the container size by 1. If the container is full, the element at <a class="el" href="group__iterators.html#ga2871f6b985d41f3c5de71500d897bfcd" title="Returns iterator to beginning.">begin()</a> is overwritten. Makes no copies of val, and val must be <em>move-assignable</em>.<br  />
 Double-ended queues are designed to be efficient performing insertions (and removals) from either the end or the beginning of the sequence. Insertions on other positions are usually less efficient than in list or forward_list containers.<br  />
 <b> Complexity:</b> Linear on the number of elements inserted (copy/move construction) plus an additional linear in the number of elements between position and the end of the container.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references from position to the end of the queue are invalidated.<br  />
 <b> Data Races:</b> The container is modified. It is not safe to concurrently access elements.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If allocator_traits::construct is not supported with the appropriate arguments for the element constructions, or if an invalid position or range is specified, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position in the container where the new elements are inserted. Iterator is a member type, defined as a random access iterator type that points to elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. Member type value_type is the type of the elements in the container, defined in deque as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__modifiers.html#ga210ab61a9304ffe9bddfa5488f4399bc" title="Add element at the end.">push_back()</a> </dd>
<dd>
<a class="el" href="group__modifiers.html#ga47686bfa34c8a6d48296559410ca3921" title="Add element at beginning.">push_front()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted element. </dd></dl>

</div>
</div>
<a id="gab5388dd06cc55b5000e7538838c084df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5388dd06cc55b5000e7538838c084df">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete last element. </p>
<p>Removes the last element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> container, effectively reducing its size by one. This destroys the removed element. Popping an empty queue results in undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The iterators, pointers and references referring to the removed element are invalidated. Iterators, pointers and references referring to other elements that have not been removed are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. The last element is modified. Concurrently accessing or modifying other elements is safe (although see iterator validity above).<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior. </p>

</div>
</div>
<a id="gabae9d128b3688087c01d262e5076120d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae9d128b3688087c01d262e5076120d">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete first element. </p>
<p>Removes the first element in the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> container, effectively reducing its size by one. This destroys the removed element. Popping an empty queue results in undefined behavior.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> The iterators, pointers and references referring to the removed element are invalidated. Iterators, pointers and references referring to other elements that have not been removed are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. The first element is modified. Concurrently accessing or modifying other elements is safe (although see iterator validity above).<br  />
 <b> Exception Safety:</b> If the container is not empty, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior. </p>

</div>
</div>
<a id="ga210ab61a9304ffe9bddfa5488f4399bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210ab61a9304ffe9bddfa5488f4399bc">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at the end. </p>
<p>Adds a new element at the end of the container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. If the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> is full, it will cause the element at the front of the queue to be overwritten.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> Only the end iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. If full, the first element in the queue is modified. Concurrently accessing or modifying other elements is safe.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If the element is copyable or no-throw movable, then there are no side effects (strong guarantee). If the container is not full, then there are no side effects (strong guarantee). If the container is full, and an exception occurs, the first element in the container will be destroyed. If allocator_traits::construct is not supported with val as argument, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to copy/move into the end of the container. Member type value_type is the type of the elements in the container, defined in vector as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47686bfa34c8a6d48296559410ca3921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47686bfa34c8a6d48296559410ca3921">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcircular__queue.html#afbe7f924c5a762af802d72fc83aa880e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at beginning. </p>
<p>Adds a new element at the beginning of the container, right before its current first element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. If the <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> is full, it will cause the element at the end of the queue to be overwritten.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> Only the begin iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.<br  />
 <b> Data Races:</b> The container is modified. If full, the last element in the queue is modified. Concurrently accessing or modifying other elements is safe.<br  />
 <b> Exception Safety:</b> The container is guaranteed to end in a valid state (basic guarantee). If the element is copyable or no-throw movable, then there are no side effects (strong guarantee). If allocator_traits::construct is not supported with val as argument, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to copy/move into the end of the container. Member type value_type is the type of the elements in the container, defined in vector as an alias of its first template parameter (T). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7740220a997ddda8b97d21326da163a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7740220a997ddda8b97d21326da163a6">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcircular__queue.html">circular_queue</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content. </p>
<p>Exchanges the content of the container by the content of <em>other</em>, which is another <a class="el" href="classcircular__queue.html" title="Fixed capacity, STL-style, templated circular buffer.">circular_queue</a> object containing elements of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in <em>other</em> before the call, and the elements of <em>other</em> are those which were in <em>this</em>. All iterators, references and pointers remain valid for the swapped objects. Notice that a non-member function exists with the same name, swap, overloading that algorithm with an optimization that behaves like this member function.<br  />
 <b> Complexity:</b> Constant.<br  />
 <b> Iterator Validity:</b> All iterators, pointers and references referring to elements in both containers remain valid, and are now referring to the same elements they referred to before the call, but in the other container, where they now iterate.<br  />
 <b> Data Races:</b> Both the container and <em>other</em> are modified. No contained elements are accessed by the call.<br  />
 <b> Exception Safety:</b> If the allocators in both containers compare equal, or if their allocator traits indicate that the allocators shall propagate, the function never throws exceptions (no-throw guarantee). Otherwise, it causes undefined behavior.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to swap with <em>this</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
