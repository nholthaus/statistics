<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Queue: concurrent_queue&lt; T, Queue, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Queue
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A C++17 Library of various `queue` containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classconcurrent__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classconcurrent__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">concurrent_queue&lt; T, Queue, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a></code> class is a sequence container class that allows first-in, first-out access to its elements.  
 <a href="classconcurrent__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__queue_8h_source.html">concurrent_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95c2b949536c14cc0478eca126536d68"><td class="memItemLeft" align="right" valign="top"><a id="a95c2b949536c14cc0478eca126536d68"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a95c2b949536c14cc0478eca126536d68">value_type</a></td></tr>
<tr class="memdesc:a95c2b949536c14cc0478eca126536d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents the data type stored in a concurrent queue. <br /></td></tr>
<tr class="separator:a95c2b949536c14cc0478eca126536d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0f5f792f64ecde8bccca83e11e4faa"><td class="memItemLeft" align="right" valign="top"><a id="adb0f5f792f64ecde8bccca83e11e4faa"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a></td></tr>
<tr class="memdesc:adb0f5f792f64ecde8bccca83e11e4faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents the allocator class for the concurrent queue. <br /></td></tr>
<tr class="separator:adb0f5f792f64ecde8bccca83e11e4faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5b2ba2d81e5de33cfe05e44893a113"><td class="memItemLeft" align="right" valign="top"><a id="aac5b2ba2d81e5de33cfe05e44893a113"></a>
typedef <a class="el" href="classconcurrent__queue.html#a95c2b949536c14cc0478eca126536d68">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aac5b2ba2d81e5de33cfe05e44893a113">reference</a></td></tr>
<tr class="memdesc:aac5b2ba2d81e5de33cfe05e44893a113"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides a reference to an element stored in a concurrent queue. <br /></td></tr>
<tr class="separator:aac5b2ba2d81e5de33cfe05e44893a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07626becccebb7602b3f77ff38eca21"><td class="memItemLeft" align="right" valign="top"><a id="ac07626becccebb7602b3f77ff38eca21"></a>
typedef std::condition_variable_any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ac07626becccebb7602b3f77ff38eca21">condition_type</a></td></tr>
<tr class="memdesc:ac07626becccebb7602b3f77ff38eca21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides a waitable condition of the concurrent queue. <br /></td></tr>
<tr class="separator:ac07626becccebb7602b3f77ff38eca21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe677a95317be2176f9ee3e13743e4c"><td class="memItemLeft" align="right" valign="top"><a id="a5fe677a95317be2176f9ee3e13743e4c"></a>
typedef std::allocator_traits&lt; <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &gt;::<a class="el" href="classconcurrent__queue.html#a5fe677a95317be2176f9ee3e13743e4c">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a5fe677a95317be2176f9ee3e13743e4c">pointer</a></td></tr>
<tr class="memdesc:a5fe677a95317be2176f9ee3e13743e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides a pointer to an element stored in a concurrent queue. <br /></td></tr>
<tr class="separator:a5fe677a95317be2176f9ee3e13743e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada44980c3d3c5513a4dd27e711ca4dfe"><td class="memItemLeft" align="right" valign="top"><a id="ada44980c3d3c5513a4dd27e711ca4dfe"></a>
typedef std::allocator_traits&lt; <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &gt;::<a class="el" href="classconcurrent__queue.html#ada44980c3d3c5513a4dd27e711ca4dfe">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ada44980c3d3c5513a4dd27e711ca4dfe">const_pointer</a></td></tr>
<tr class="memdesc:ada44980c3d3c5513a4dd27e711ca4dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides a const pointer to an element stored in a concurrent queue. <br /></td></tr>
<tr class="separator:ada44980c3d3c5513a4dd27e711ca4dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56308fc6ab8b410346432495e570298"><td class="memItemLeft" align="right" valign="top"><a id="ae56308fc6ab8b410346432495e570298"></a>
typedef Queue&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ae56308fc6ab8b410346432495e570298">queue_type</a></td></tr>
<tr class="memdesc:ae56308fc6ab8b410346432495e570298"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents the underlying non-thread-safe data structure for the concurrent queue. <br /></td></tr>
<tr class="separator:ae56308fc6ab8b410346432495e570298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514d1ed6aad16e1ab9e4426c10f4a14"><td class="memItemLeft" align="right" valign="top"><a id="a8514d1ed6aad16e1ab9e4426c10f4a14"></a>
typedef queue_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a></td></tr>
<tr class="memdesc:a8514d1ed6aad16e1ab9e4426c10f4a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents a non-thread-safe iterator over the elements in a concurrent queue. <br /></td></tr>
<tr class="separator:a8514d1ed6aad16e1ab9e4426c10f4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265d4b40128b519d58ca33c7104cdb27"><td class="memItemLeft" align="right" valign="top"><a id="a265d4b40128b519d58ca33c7104cdb27"></a>
typedef queue_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a></td></tr>
<tr class="memdesc:a265d4b40128b519d58ca33c7104cdb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents a non-thread-safe const iterator over elements in a concurrent queue. <br /></td></tr>
<tr class="separator:a265d4b40128b519d58ca33c7104cdb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ead0c9241e6018bbaeb66fd45d89bea"><td class="memItemLeft" align="right" valign="top"><a id="a4ead0c9241e6018bbaeb66fd45d89bea"></a>
typedef std::reverse_iterator&lt; <a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a4ead0c9241e6018bbaeb66fd45d89bea">reverse_iterator</a></td></tr>
<tr class="memdesc:a4ead0c9241e6018bbaeb66fd45d89bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents a reverse non-thread-safe iterator over the elements in a concurrent queue. <br /></td></tr>
<tr class="separator:a4ead0c9241e6018bbaeb66fd45d89bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b488bcec7ac57464d5455713a72a01"><td class="memItemLeft" align="right" valign="top"><a id="ac1b488bcec7ac57464d5455713a72a01"></a>
typedef std::reverse_iterator&lt; <a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ac1b488bcec7ac57464d5455713a72a01">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ac1b488bcec7ac57464d5455713a72a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents a reverse non-thread-safe const iterator over elements in a concurrent queue. <br /></td></tr>
<tr class="separator:ac1b488bcec7ac57464d5455713a72a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad604e025764ac607ae9a3e805782ff31"><td class="memItemLeft" align="right" valign="top"><a id="ad604e025764ac607ae9a3e805782ff31"></a>
typedef std::shared_timed_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ad604e025764ac607ae9a3e805782ff31">mutex_type</a></td></tr>
<tr class="memdesc:ad604e025764ac607ae9a3e805782ff31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents the mutex protecting the concurrent queue. <br /></td></tr>
<tr class="separator:ad604e025764ac607ae9a3e805782ff31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8254c8bb51cacdb953a9475a529091a"><td class="memItemLeft" align="right" valign="top"><a id="ae8254c8bb51cacdb953a9475a529091a"></a>
typedef std::shared_lock&lt; <a class="el" href="classconcurrent__queue.html#ad604e025764ac607ae9a3e805782ff31">mutex_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ae8254c8bb51cacdb953a9475a529091a">read_lock_type</a></td></tr>
<tr class="memdesc:ae8254c8bb51cacdb953a9475a529091a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a lock on the concurrent queue's mutex which is sufficient to read data in a thread-safe manner. <br /></td></tr>
<tr class="separator:ae8254c8bb51cacdb953a9475a529091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa294727bed30f901769e49e251a7ae41"><td class="memItemLeft" align="right" valign="top"><a id="aa294727bed30f901769e49e251a7ae41"></a>
typedef std::unique_lock&lt; <a class="el" href="classconcurrent__queue.html#ad604e025764ac607ae9a3e805782ff31">mutex_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aa294727bed30f901769e49e251a7ae41">write_lock_type</a></td></tr>
<tr class="memdesc:aa294727bed30f901769e49e251a7ae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a lock on the concurrent queue's mutex which is sufficient to write data in a thread-safe manner. <br /></td></tr>
<tr class="separator:aa294727bed30f901769e49e251a7ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0246336971767115b788dacc5c457aab"><td class="memItemLeft" align="right" valign="top"><a id="a0246336971767115b788dacc5c457aab"></a>
typedef std::iterator_traits&lt; <a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a> &gt;::<a class="el" href="classconcurrent__queue.html#a0246336971767115b788dacc5c457aab">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a0246336971767115b788dacc5c457aab">difference_type</a></td></tr>
<tr class="memdesc:a0246336971767115b788dacc5c457aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides the signed distance between two elements in a concurrent queue. <br /></td></tr>
<tr class="separator:a0246336971767115b788dacc5c457aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fce550b460f5cfac7321df31ef876"><td class="memItemLeft" align="right" valign="top"><a id="acb3fce550b460f5cfac7321df31ef876"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#acb3fce550b460f5cfac7321df31ef876">size_type</a></td></tr>
<tr class="memdesc:acb3fce550b460f5cfac7321df31ef876"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that counts the number of elements in a concurrent queue. <br /></td></tr>
<tr class="separator:acb3fce550b460f5cfac7321df31ef876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a08f5b924a57fb3e43ea4bf508f976668"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a08f5b924a57fb3e43ea4bf508f976668">concurrent_queue</a> ()=default</td></tr>
<tr class="memdesc:a08f5b924a57fb3e43ea4bf508f976668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classconcurrent__queue.html#a08f5b924a57fb3e43ea4bf508f976668">More...</a><br /></td></tr>
<tr class="separator:a08f5b924a57fb3e43ea4bf508f976668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18105b5bd6aeb5b96ab658057bf80a26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a18105b5bd6aeb5b96ab658057bf80a26">concurrent_queue</a> (const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a18105b5bd6aeb5b96ab658057bf80a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classconcurrent__queue.html#a18105b5bd6aeb5b96ab658057bf80a26">More...</a><br /></td></tr>
<tr class="separator:a18105b5bd6aeb5b96ab658057bf80a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ecc8f38e08665ad75f08ddab7be3de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a36ecc8f38e08665ad75f08ddab7be3de">concurrent_queue</a> (<a class="el" href="classconcurrent__queue.html#acb3fce550b460f5cfac7321df31ef876">size_type</a> n, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc=<a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>())</td></tr>
<tr class="memdesc:a36ecc8f38e08665ad75f08ddab7be3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill Constructor.  <a href="classconcurrent__queue.html#a36ecc8f38e08665ad75f08ddab7be3de">More...</a><br /></td></tr>
<tr class="separator:a36ecc8f38e08665ad75f08ddab7be3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2182da81fc5462d03d4ba86cdf297"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#adca2182da81fc5462d03d4ba86cdf297">concurrent_queue</a> (<a class="el" href="classconcurrent__queue.html#acb3fce550b460f5cfac7321df31ef876">size_type</a> n, const <a class="el" href="classconcurrent__queue.html#a95c2b949536c14cc0478eca126536d68">value_type</a> &amp;val, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc=<a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>())</td></tr>
<tr class="memdesc:adca2182da81fc5462d03d4ba86cdf297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill Constructor.  <a href="classconcurrent__queue.html#adca2182da81fc5462d03d4ba86cdf297">More...</a><br /></td></tr>
<tr class="separator:adca2182da81fc5462d03d4ba86cdf297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a4db7bff4af076a1b8e12805454ce3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a98a4db7bff4af076a1b8e12805454ce3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a98a4db7bff4af076a1b8e12805454ce3">concurrent_queue</a> (InputIterator first, InputIterator last, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc=<a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>())</td></tr>
<tr class="memdesc:a98a4db7bff4af076a1b8e12805454ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range Constructor.  <a href="classconcurrent__queue.html#a98a4db7bff4af076a1b8e12805454ce3">More...</a><br /></td></tr>
<tr class="separator:a98a4db7bff4af076a1b8e12805454ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa653012dcc453bbd63e08696bcc1f57b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aa653012dcc453bbd63e08696bcc1f57b">concurrent_queue</a> (const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;other)</td></tr>
<tr class="memdesc:aa653012dcc453bbd63e08696bcc1f57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="classconcurrent__queue.html#aa653012dcc453bbd63e08696bcc1f57b">More...</a><br /></td></tr>
<tr class="separator:aa653012dcc453bbd63e08696bcc1f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85b9123eb591e8fab18752e572ed7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aca85b9123eb591e8fab18752e572ed7f">concurrent_queue</a> (const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;other, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:aca85b9123eb591e8fab18752e572ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor with allocator.  <a href="classconcurrent__queue.html#aca85b9123eb591e8fab18752e572ed7f">More...</a><br /></td></tr>
<tr class="separator:aca85b9123eb591e8fab18752e572ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f0adca7f4e31c508837418c6bc76fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a51f0adca7f4e31c508837418c6bc76fa">concurrent_queue</a> (<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a51f0adca7f4e31c508837418c6bc76fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor.  <a href="classconcurrent__queue.html#a51f0adca7f4e31c508837418c6bc76fa">More...</a><br /></td></tr>
<tr class="separator:a51f0adca7f4e31c508837418c6bc76fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045288d55a2f6c0017cb7b31f46b41ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a045288d55a2f6c0017cb7b31f46b41ac">concurrent_queue</a> (<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;&amp;other, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a045288d55a2f6c0017cb7b31f46b41ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor.  <a href="classconcurrent__queue.html#a045288d55a2f6c0017cb7b31f46b41ac">More...</a><br /></td></tr>
<tr class="separator:a045288d55a2f6c0017cb7b31f46b41ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6426fd5db5379b1aef03ecc50e3a01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a4b6426fd5db5379b1aef03ecc50e3a01">concurrent_queue</a> (std::initializer_list&lt; T &gt; init, const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;alloc=<a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>())</td></tr>
<tr class="memdesc:a4b6426fd5db5379b1aef03ecc50e3a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer List Constructor.  <a href="classconcurrent__queue.html#a4b6426fd5db5379b1aef03ecc50e3a01">More...</a><br /></td></tr>
<tr class="separator:a4b6426fd5db5379b1aef03ecc50e3a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a3a356aead82db9d91249df34d9b0fd71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a3a356aead82db9d91249df34d9b0fd71">~concurrent_queue</a> ()=default</td></tr>
<tr class="memdesc:a3a356aead82db9d91249df34d9b0fd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classconcurrent__queue.html#a3a356aead82db9d91249df34d9b0fd71">More...</a><br /></td></tr>
<tr class="separator:a3a356aead82db9d91249df34d9b0fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment Operators</div></td></tr>
<tr class="memitem:a2b01bb1ba1efba491d4b4c8bbbcf5f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a2b01bb1ba1efba491d4b4c8bbbcf5f6a">operator=</a> (const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;other)</td></tr>
<tr class="memdesc:a2b01bb1ba1efba491d4b4c8bbbcf5f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Assignment Operator.  <a href="classconcurrent__queue.html#a2b01bb1ba1efba491d4b4c8bbbcf5f6a">More...</a><br /></td></tr>
<tr class="separator:a2b01bb1ba1efba491d4b4c8bbbcf5f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b41d262614e3a5ec30c0b0268f15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ade9b41d262614e3a5ec30c0b0268f15a">operator=</a> (<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ade9b41d262614e3a5ec30c0b0268f15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment Operator.  <a href="classconcurrent__queue.html#ade9b41d262614e3a5ec30c0b0268f15a">More...</a><br /></td></tr>
<tr class="separator:ade9b41d262614e3a5ec30c0b0268f15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread-safe Public Members</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are safe for use in situations where the queue will be concurrently accessed by multiple threads. </p>
</div></td></tr>
<tr class="memitem:a8717d34942607233bd2ca00d1616d0af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a8717d34942607233bd2ca00d1616d0af">clear</a> () noexcept</td></tr>
<tr class="memdesc:a8717d34942607233bd2ca00d1616d0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the concurrent queue, destroying any currently enqueued elements.  <a href="classconcurrent__queue.html#a8717d34942607233bd2ca00d1616d0af">More...</a><br /></td></tr>
<tr class="separator:a8717d34942607233bd2ca00d1616d0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb30121d123d995100dd8c129ceb753"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abeb30121d123d995100dd8c129ceb753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#abeb30121d123d995100dd8c129ceb753">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abeb30121d123d995100dd8c129ceb753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new element in place at the end of the concurrent queue.  <a href="classconcurrent__queue.html#abeb30121d123d995100dd8c129ceb753">More...</a><br /></td></tr>
<tr class="separator:abeb30121d123d995100dd8c129ceb753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867b2fda3c7193104986e8a4e21f99ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a867b2fda3c7193104986e8a4e21f99ab">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a867b2fda3c7193104986e8a4e21f99ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the concurrent queue is empty at the moment this method is called.  <a href="classconcurrent__queue.html#a867b2fda3c7193104986e8a4e21f99ab">More...</a><br /></td></tr>
<tr class="separator:a867b2fda3c7193104986e8a4e21f99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93ffc95789800add478f98a35bf2307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aa93ffc95789800add478f98a35bf2307">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:aa93ffc95789800add478f98a35bf2307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator used to construct the concurrent queue.  <a href="classconcurrent__queue.html#aa93ffc95789800add478f98a35bf2307">More...</a><br /></td></tr>
<tr class="separator:aa93ffc95789800add478f98a35bf2307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484cb5b5e80ac9aad76d0e4ad2218b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a484cb5b5e80ac9aad76d0e4ad2218b8c">push</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a484cb5b5e80ac9aad76d0e4ad2218b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues an item at tail end of the concurrent queue.  <a href="classconcurrent__queue.html#a484cb5b5e80ac9aad76d0e4ad2218b8c">More...</a><br /></td></tr>
<tr class="separator:a484cb5b5e80ac9aad76d0e4ad2218b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca9999a478a99b458ecc7a2ed5ef046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a1ca9999a478a99b458ecc7a2ed5ef046">push</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a1ca9999a478a99b458ecc7a2ed5ef046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues an item at tail end of the concurrent queue.  <a href="classconcurrent__queue.html#a1ca9999a478a99b458ecc7a2ed5ef046">More...</a><br /></td></tr>
<tr class="separator:a1ca9999a478a99b458ecc7a2ed5ef046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d6cd31e87683762f2fc110bb1c1024"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a13d6cd31e87683762f2fc110bb1c1024">size</a> () const</td></tr>
<tr class="memdesc:a13d6cd31e87683762f2fc110bb1c1024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the queue.  <a href="classconcurrent__queue.html#a13d6cd31e87683762f2fc110bb1c1024">More...</a><br /></td></tr>
<tr class="separator:a13d6cd31e87683762f2fc110bb1c1024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac500ad7f2cc6faff601dd1d4d0d3022e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ac500ad7f2cc6faff601dd1d4d0d3022e">try_pop</a> (T &amp;destination)</td></tr>
<tr class="memdesc:ac500ad7f2cc6faff601dd1d4d0d3022e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues an item from the queue if one is available.  <a href="classconcurrent__queue.html#ac500ad7f2cc6faff601dd1d4d0d3022e">More...</a><br /></td></tr>
<tr class="separator:ac500ad7f2cc6faff601dd1d4d0d3022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329e5cc8b2de37f23760031bf3cc2dd0"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a329e5cc8b2de37f23760031bf3cc2dd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a329e5cc8b2de37f23760031bf3cc2dd0">try_pop_for</a> (T &amp;destination, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration)</td></tr>
<tr class="memdesc:a329e5cc8b2de37f23760031bf3cc2dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues an item from the queue if one is available within the specified timeout.  <a href="classconcurrent__queue.html#a329e5cc8b2de37f23760031bf3cc2dd0">More...</a><br /></td></tr>
<tr class="separator:a329e5cc8b2de37f23760031bf3cc2dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread-unsafe Public Members</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are not recommended for use in production code and will generate warnings when used. That said, they're helpful for testing and debug, which is why they are included. </p>
</div></td></tr>
<tr class="memitem:a1e2e92b430a49e2c77c638b6663c3a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a1e2e92b430a49e2c77c638b6663c3a74">begin</a> ()</td></tr>
<tr class="memdesc:a1e2e92b430a49e2c77c638b6663c3a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type iterator to the beginning of the concurrent queue.  <a href="classconcurrent__queue.html#a1e2e92b430a49e2c77c638b6663c3a74">More...</a><br /></td></tr>
<tr class="separator:a1e2e92b430a49e2c77c638b6663c3a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360a74ce385dd66318c415b51f7e057b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a360a74ce385dd66318c415b51f7e057b">begin</a> () const</td></tr>
<tr class="memdesc:a360a74ce385dd66318c415b51f7e057b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type const_iterator to the beginning of the concurrent queue.  <a href="classconcurrent__queue.html#a360a74ce385dd66318c415b51f7e057b">More...</a><br /></td></tr>
<tr class="separator:a360a74ce385dd66318c415b51f7e057b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387883ff66732e4aa8b72dbdf18b1bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a387883ff66732e4aa8b72dbdf18b1bb5">cbegin</a> () const</td></tr>
<tr class="memdesc:a387883ff66732e4aa8b72dbdf18b1bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type const_iterator to the beginning of the concurrent queue.  <a href="classconcurrent__queue.html#a387883ff66732e4aa8b72dbdf18b1bb5">More...</a><br /></td></tr>
<tr class="separator:a387883ff66732e4aa8b72dbdf18b1bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be49f49ac5a58a2bbd1960bb1fbb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a38be49f49ac5a58a2bbd1960bb1fbb5b">end</a> ()</td></tr>
<tr class="memdesc:a38be49f49ac5a58a2bbd1960bb1fbb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type iterator to the end of the concurrent queue.  <a href="classconcurrent__queue.html#a38be49f49ac5a58a2bbd1960bb1fbb5b">More...</a><br /></td></tr>
<tr class="separator:a38be49f49ac5a58a2bbd1960bb1fbb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b9eabd49b05b8a67cdccb72a840c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a21b9eabd49b05b8a67cdccb72a840c5e">end</a> () const</td></tr>
<tr class="memdesc:a21b9eabd49b05b8a67cdccb72a840c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type const_iterator to the end of the concurrent queue.  <a href="classconcurrent__queue.html#a21b9eabd49b05b8a67cdccb72a840c5e">More...</a><br /></td></tr>
<tr class="separator:a21b9eabd49b05b8a67cdccb72a840c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f140c36164bffb4d09c27e8b5b738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#afc7f140c36164bffb4d09c27e8b5b738">cend</a> () const</td></tr>
<tr class="memdesc:afc7f140c36164bffb4d09c27e8b5b738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator of type const_iterator to the end of the concurrent queue.  <a href="classconcurrent__queue.html#afc7f140c36164bffb4d09c27e8b5b738">More...</a><br /></td></tr>
<tr class="separator:afc7f140c36164bffb4d09c27e8b5b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide the ability to lock the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> for thread-safe iteration. They are primarily intended for test and debug use, and care must be taken when explicitely locking the queue to avoid deadlock. These methods are NOT recommended for production code, and will produce warnings when used. </p>
</div></td></tr>
<tr class="memitem:a3ddd58258bd477147f9c33888341b621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#ae8254c8bb51cacdb953a9475a529091a">read_lock_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a3ddd58258bd477147f9c33888341b621">acquire_read_lock</a> () const</td></tr>
<tr class="memdesc:a3ddd58258bd477147f9c33888341b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the queue in a manner in which it is safe for multiple threads to read-iterate over it.  <a href="classconcurrent__queue.html#a3ddd58258bd477147f9c33888341b621">More...</a><br /></td></tr>
<tr class="separator:a3ddd58258bd477147f9c33888341b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d30ced4bced14b8203ce312f22b822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classconcurrent__queue.html#aa294727bed30f901769e49e251a7ae41">write_lock_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#af4d30ced4bced14b8203ce312f22b822">acquire_write_lock</a> ()</td></tr>
<tr class="memdesc:af4d30ced4bced14b8203ce312f22b822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the queue in a manner in which it is safe for multiple threads to write-iterate over it.  <a href="classconcurrent__queue.html#af4d30ced4bced14b8203ce312f22b822">More...</a><br /></td></tr>
<tr class="separator:af4d30ced4bced14b8203ce312f22b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa7ee2dc850b2ef0302c945a4a7f36a1d"><td class="memItemLeft" align="right" valign="top"><a id="aa7ee2dc850b2ef0302c945a4a7f36a1d"></a>
const typedef <a class="el" href="classconcurrent__queue.html#a95c2b949536c14cc0478eca126536d68">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#aa7ee2dc850b2ef0302c945a4a7f36a1d">const_reference</a></td></tr>
<tr class="memdesc:aa7ee2dc850b2ef0302c945a4a7f36a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that provides a reference to a const element stored in a concurrent queue for reading and performing const operations. <br /></td></tr>
<tr class="separator:aa7ee2dc850b2ef0302c945a4a7f36a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Equality Operators</div></td></tr>
<tr class="memitem:a12f3bbec54c3c0fb715d612b186efeb2"><td class="memTemplParams" colspan="2">template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </td></tr>
<tr class="memitem:a12f3bbec54c3c0fb715d612b186efeb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a12f3bbec54c3c0fb715d612b186efeb2">operator==</a> (const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;lhs, const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a12f3bbec54c3c0fb715d612b186efeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality Operator.  <a href="classconcurrent__queue.html#a12f3bbec54c3c0fb715d612b186efeb2">More...</a><br /></td></tr>
<tr class="separator:a12f3bbec54c3c0fb715d612b186efeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c56830439f29cf164e12317025b63c"><td class="memTemplParams" colspan="2">template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </td></tr>
<tr class="memitem:ad0c56830439f29cf164e12317025b63c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#ad0c56830439f29cf164e12317025b63c">operator!=</a> (const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;lhs, const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad0c56830439f29cf164e12317025b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality Operator.  <a href="classconcurrent__queue.html#ad0c56830439f29cf164e12317025b63c">More...</a><br /></td></tr>
<tr class="separator:ad0c56830439f29cf164e12317025b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Swap Operator</div></td></tr>
<tr class="memitem:a9822e23868816e2f7efb9710fdb9e4da"><td class="memTemplParams" colspan="2">template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </td></tr>
<tr class="memitem:a9822e23868816e2f7efb9710fdb9e4da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__queue.html#a9822e23868816e2f7efb9710fdb9e4da">std::swap</a> (<a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;lhs, <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9822e23868816e2f7efb9710fdb9e4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap Operator.  <a href="classconcurrent__queue.html#a9822e23868816e2f7efb9710fdb9e4da">More...</a><br /></td></tr>
<tr class="separator:a9822e23868816e2f7efb9710fdb9e4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, template&lt; class, class &gt; class Queue = std::deque, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class concurrent_queue&lt; T, Queue, Alloc &gt;</h3>

<p>The <code><a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a></code> class is a sequence container class that allows first-in, first-out access to its elements. </p>
<p>It enables a limited set of concurrency-safe operations, such as push and try_pop. Here, concurrency-safe means pointers or iterators are always valid. It's not a guarantee of element initialization, or of a particular traversal order. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the elements to be stored in the queue. </td></tr>
    <tr><td class="paramname">Queue</td><td>Underlying concurrent queue data structure. Defaults to <code>std::deque</code>. </td></tr>
    <tr><td class="paramname">AllocThe</td><td>type that represents the stored allocator object that encapsulates details about the allocation and deallocation of memory for this concurrent queue. This argument is optional and the default value is allocator&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a08f5b924a57fb3e43ea4bf508f976668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f5b924a57fb3e43ea4bf508f976668">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>Constructs an empty container, with no elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>optional memory allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18105b5bd6aeb5b96ab658057bf80a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18105b5bd6aeb5b96ab658057bf80a26">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>Constructs an empty container, with no elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>optional memory allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ecc8f38e08665ad75f08ddab7be3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ecc8f38e08665ad75f08ddab7be3de">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html#acb3fce550b460f5cfac7321df31ef876">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill Constructor. </p>
<p>Constructs a container with n elements. Each element is a copy of val (if provided). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>optional memory allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adca2182da81fc5462d03d4ba86cdf297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca2182da81fc5462d03d4ba86cdf297">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html#acb3fce550b460f5cfac7321df31ef876">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#a95c2b949536c14cc0478eca126536d68">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill Constructor. </p>
<p>Constructs a container with n elements. Each element is a copy of val (if provided). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to fill the concurrent queue with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>optional memory allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a4db7bff4af076a1b8e12805454ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a4db7bff4af076a1b8e12805454ce3">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range Constructor. </p>
<p>Constructs a container with as many elements as the range [first,last), with each element emplace-constructed from its corresponding element in that range, in the same order. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Input Iterator to value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the one-past-last element of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa653012dcc453bbd63e08696bcc1f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa653012dcc453bbd63e08696bcc1f57b">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<p>Constructs a container with a copy of each of the elements in x, in the same order. Thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>queue to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca85b9123eb591e8fab18752e572ed7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca85b9123eb591e8fab18752e572ed7f">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Constructor with allocator. </p>
<p>Constructs a container with a copy of each of the elements in x, in the same order. Thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>queue to copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>optional memory allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f0adca7f4e31c508837418c6bc76fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f0adca7f4e31c508837418c6bc76fa">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Constructor. </p>
<p>Constructs a container that acquires the elements of <code>other</code>. Ownership of the contained elements is directly transferred. <code>other</code> is left in an unspecified but valid state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a045288d55a2f6c0017cb7b31f46b41ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045288d55a2f6c0017cb7b31f46b41ac">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Constructor. </p>
<p>Constructs a container that acquires the elements of <code>other</code>. Ownership of the contained elements is directly transferred. <code>other</code> is left in an unspecified but valid state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>container to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b6426fd5db5379b1aef03ecc50e3a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6426fd5db5379b1aef03ecc50e3a01">&#9670;&nbsp;</a></span>concurrent_queue() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer List Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a356aead82db9d91249df34d9b0fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a356aead82db9d91249df34d9b0fd71">&#9670;&nbsp;</a></span>~concurrent_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::~<a class="el" href="classconcurrent__queue.html">concurrent_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destructs the concurrent queue. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ddd58258bd477147f9c33888341b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddd58258bd477147f9c33888341b621">&#9670;&nbsp;</a></span>acquire_read_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#ae8254c8bb51cacdb953a9475a529091a">read_lock_type</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::acquire_read_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the queue in a manner in which it is safe for multiple threads to read-iterate over it. </p>
<p>Allows concurrency-safe iteration. </p><dl class="section remark"><dt>Remarks</dt><dd>Intended for test and debug use only. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RAII lock suitable for safe read-iteration. Note that failure to move from or bind to the return value will invoke the locks destructor at the end of the call, instantly unlocking the concurrent queue. </dd></dl>

</div>
</div>
<a id="af4d30ced4bced14b8203ce312f22b822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d30ced4bced14b8203ce312f22b822">&#9670;&nbsp;</a></span>acquire_write_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#aa294727bed30f901769e49e251a7ae41">write_lock_type</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::acquire_write_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the queue in a manner in which it is safe for multiple threads to write-iterate over it. </p>
<p>Allows concurrency-safe iteration. </p><dl class="section remark"><dt>Remarks</dt><dd>Intended for test and debug use only. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RAII lock suitable for safe write-iteration. Note that failure to move from or bind to the return value will invoke the locks destructor at the end of the call, instantly unlocking the concurrent queue. </dd></dl>

</div>
</div>
<a id="a1e2e92b430a49e2c77c638b6663c3a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e92b430a49e2c77c638b6663c3a74">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type iterator to the beginning of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type iterator to the beginning of the concurrent queue. </dd></dl>

</div>
</div>
<a id="a360a74ce385dd66318c415b51f7e057b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360a74ce385dd66318c415b51f7e057b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type const_iterator to the beginning of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type const_iterator to the beginning of the concurrent queue. </dd></dl>

</div>
</div>
<a id="a387883ff66732e4aa8b72dbdf18b1bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387883ff66732e4aa8b72dbdf18b1bb5">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type const_iterator to the beginning of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type const_iterator to the beginning of the concurrent queue. </dd></dl>

</div>
</div>
<a id="afc7f140c36164bffb4d09c27e8b5b738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7f140c36164bffb4d09c27e8b5b738">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type const_iterator to the end of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type const_iterator to the end of the concurrent queue. </dd></dl>

</div>
</div>
<a id="a8717d34942607233bd2ca00d1616d0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8717d34942607233bd2ca00d1616d0af">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the concurrent queue, destroying any currently enqueued elements. </p>
<p>This method is not concurrency-safe, and invalidates all iterators. </p>

</div>
</div>
<a id="abeb30121d123d995100dd8c129ceb753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30121d123d995100dd8c129ceb753">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new element in place at the end of the concurrent queue. </p>
<p>This method is concurrency-safe. This method is concurrency-safe with respect to calls to the methods <code>push</code>, <code>emplace</code>, <code>pop</code>, and <code>empty</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types of args, generally deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a867b2fda3c7193104986e8a4e21f99ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867b2fda3c7193104986e8a4e21f99ab">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the concurrent queue is empty at the moment this method is called. </p>
<p>This method is concurrency-safe. While this method is concurrency-safe with respect to calls to the methods <code>push</code>, <code>emplace</code>, <code>pop</code>, and <code>empty</code>, the value returned might be incorrect by the time it is inspected by the calling thread. </p><dl class="section return"><dt>Returns</dt><dd>true if the concurrent queue was empty at the moment we looked, false otherwise. </dd></dl>

</div>
</div>
<a id="a38be49f49ac5a58a2bbd1960bb1fbb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38be49f49ac5a58a2bbd1960bb1fbb5b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a8514d1ed6aad16e1ab9e4426c10f4a14">iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type iterator to the end of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type iterator to the end of the concurrent queue. </dd></dl>

</div>
</div>
<a id="a21b9eabd49b05b8a67cdccb72a840c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b9eabd49b05b8a67cdccb72a840c5e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#a265d4b40128b519d58ca33c7104cdb27">const_iterator</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator of type const_iterator to the end of the concurrent queue. </p>
<p>This method is not concurrency-safe. The iterators for the <a class="el" href="classconcurrent__queue.html" title="The concurrent_queue class is a sequence container class that allows first-in, first-out access to it...">concurrent_queue</a> class are primarily intended for debugging, as they are slow, and iteration is not concurrency-safe with respect to other queue operations. </p><dl class="section return"><dt>Returns</dt><dd>An iterator of type const_iterator to the end of the concurrent queue. </dd></dl>

</div>
</div>
<a id="aa93ffc95789800add478f98a35bf2307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93ffc95789800add478f98a35bf2307">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html#adb0f5f792f64ecde8bccca83e11e4faa">allocator_type</a> <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the allocator used to construct the concurrent queue. </p>
<p>This method is concurrency-safe. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the allocator used to construct the concurrent queue. </dd></dl>

</div>
</div>
<a id="ade9b41d262614e3a5ec30c0b0268f15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b41d262614e3a5ec30c0b0268f15a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&amp; <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>concurrent queue whose elements are to be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this concurrent queue. </dd></dl>

</div>
</div>
<a id="a2b01bb1ba1efba491d4b4c8bbbcf5f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b01bb1ba1efba491d4b4c8bbbcf5f6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&amp; <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>concurrent queue whose elements are to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this concurrent queue. </dd></dl>

</div>
</div>
<a id="a484cb5b5e80ac9aad76d0e4ad2218b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484cb5b5e80ac9aad76d0e4ad2218b8c">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues an item at tail end of the concurrent queue. </p>
<p>This method is concurrency-safe. <code>push</code> is concurrency-safe with respect to calls to the methods <code>push</code> <code>emplace</code>, <code>pop</code>, and <code>empty</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The item to be added to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ca9999a478a99b458ecc7a2ed5ef046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca9999a478a99b458ecc7a2ed5ef046">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues an item at tail end of the concurrent queue. </p>
<p>This method is concurrency-safe. <code>push</code> is concurrency-safe with respect to calls to the methods <code>push</code> <code>emplace</code>, <code>pop</code>, and <code>empty</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The item to be added to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13d6cd31e87683762f2fc110bb1c1024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d6cd31e87683762f2fc110bb1c1024">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the queue. </p>
<p>This method is concurrency-safe. <code>push</code> is concurrency-safe with respect to calls to the methods <code>push</code> <code>emplace</code>, <code>try_pop</code>, and <code>empty</code>. </p><dl class="section remark"><dt>Remarks</dt><dd>While calls to size are concurrency-safe in that they cannot damage the internal state of the concurrent queue, it is unwise to use the results as a condition of a <code>for</code> loop or for iteration, because the size of the container could change between the call to <code>size</code> and the invocation of the loop's methods. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the concurrent queue. </dd></dl>

</div>
</div>
<a id="ac500ad7f2cc6faff601dd1d4d0d3022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac500ad7f2cc6faff601dd1d4d0d3022e">&#9670;&nbsp;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::try_pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues an item from the queue if one is available. </p>
<p>This method is concurrency-safe. If an item was successfully dequeued, the parameter <code>destination</code> receives the dequeued value, the original value held in the queue is destroyed, and this function returns true. If there was no item to dequeue, this function returns false without blocking, and the contents of the <code>destination</code> parameter are undefined. A false return value does not necessarily mean the queue is empty. <code>try_pop</code> is concurrency-safe with respect to calls to the methods <code>emplace</code>, <code>push</code>, <code>try_pop</code>, and <code>empty</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>A reference to a location to store the dequeued item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an item was successfully dequeued, false otherwise. </dd></dl>

</div>
</div>
<a id="a329e5cc8b2de37f23760031bf3cc2dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329e5cc8b2de37f23760031bf3cc2dd0">&#9670;&nbsp;</a></span>try_pop_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; T, Queue, Alloc &gt;::try_pop_for </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues an item from the queue if one is available within the specified timeout. </p>
<p>This method is concurrency-safe. If an item was successfully dequeued, the parameter <code>destination</code> receives the dequeued value, the original value held in the queue is destroyed, and this function returns true. If there was no item to dequeue, this function returns false without blocking, and the contents of the <code>destination</code> parameter are undefined. A false return value does not necessarily mean the queue is empty. <code>try_pop</code> is concurrency-safe with respect to calls to the methods <code>emplace</code>, <code>push</code>, <code>try_pop</code>, and <code>empty</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>A reference to a location to store the dequeued item. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_duration</td><td>The maximum length of time <code>try_pop_for</code> will attempt to pop the queue before declaring failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an item was successfully dequeued, false otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad0c56830439f29cf164e12317025b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c56830439f29cf164e12317025b63c">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Right-hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the contents of the queues are equivalent, true otherwise. </dd></dl>

</div>
</div>
<a id="a12f3bbec54c3c0fb715d612b186efeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3bbec54c3c0fb715d612b186efeb2">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Right-hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of the queues are equivalent, false otherwise. </dd></dl>

</div>
</div>
<a id="a9822e23868816e2f7efb9710fdb9e4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822e23868816e2f7efb9710fdb9e4da">&#9670;&nbsp;</a></span>std::swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class, class &gt; class Queue = std::deque, class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Ty , template&lt; class, class &gt; class Q, class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a>&lt; Ty, Q, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>container to swap with rhs </td></tr>
    <tr><td class="paramname">rhs</td><td>container to swap with lhs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="concurrent__queue_8h_source.html">concurrent_queue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classconcurrent__queue.html">concurrent_queue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
